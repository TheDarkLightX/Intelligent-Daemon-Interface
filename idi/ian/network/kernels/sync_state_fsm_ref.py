"""
Auto-generated Python reference model for: sync_state_fsm
IR hash: sha256:97071642577a11e2d97677c3efaaa8119057510fd671fce277e74e7636764170

Generated by ESSO (Evolutionary Spec Search Optimizer)

This file is standalone and has no ESSO dependencies.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Literal, Mapping


# Domain enums
STATE_SYMBOLS = ('IDLE', 'COMPARING', 'SYNCING', 'VERIFYING', 'COMPLETE', 'FAILED')


@dataclass(frozen=True)
class State:
    """Model state."""
    has_error: bool
    progress_pct: int
    state: str


@dataclass(frozen=True)
class Command:
    """Command to execute."""
    tag: Literal('compare_done', 'error_comparing', 'error_syncing', 'error_verifying', 'reset_from_complete', 'reset_from_failed', 'start_sync', 'sync_progress', 'sync_to_verify', 'verify_done')
    args: Mapping[str, Any]


@dataclass(frozen=True)
class StepResult:
    """Result of a step execution."""
    ok: bool
    state: State | None = None
    effects: Mapping[str, Any] | None = None
    error: str | None = None


def init_state() -> State:
    """Return the initial state."""
    return State(
        has_error=False,
        progress_pct=0,
        state='IDLE',
    )


def check_invariants(s: State) -> tuple[bool, str | None]:
    """Check all invariants. Returns (ok, first_failed_id)."""
    if not (isinstance(s.has_error, bool)):
        return False, 'domain_has_error'
    if not (isinstance(s.progress_pct, int) and not isinstance(s.progress_pct, bool) and 0 <= s.progress_pct <= 100):
        return False, 'domain_progress_pct'
    if not (s.state in ('IDLE', 'COMPARING', 'SYNCING', 'VERIFYING', 'COMPLETE', 'FAILED')):
        return False, 'domain_state'
    if not (((not ('COMPLETE' == s.state)) or (100 == s.progress_pct))):
        return False, 'complete_full_progress'
    if not (((not ('FAILED' == s.state)) or (True == s.has_error))):
        return False, 'failed_has_error'
    if not (((not ('IDLE' == s.state)) or (0 == s.progress_pct))):
        return False, 'idle_zero_progress'
    return True, None


def step(s: State, cmd: Command) -> StepResult:
    """Execute a step. Returns StepResult."""
    # Check pre-state invariants
    ok, failed = check_invariants(s)
    if not ok:
        return StepResult(ok=False, error=f'pre-invariant violated: {failed}')

    if cmd.tag == 'compare_done':
        if not (('COMPARING' == s.state)):
            return StepResult(ok=False, error='guard failed for compare_done')
        # Compute updates (simultaneous)
        new_state = State(
            has_error=s.has_error,
            progress_pct=10,
            state='SYNCING',
        )
        effects = {
            'event': 'COMPARE_DONE',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'error_comparing':
        if not (('COMPARING' == s.state)):
            return StepResult(ok=False, error='guard failed for error_comparing')
        # Compute updates (simultaneous)
        new_state = State(
            has_error=True,
            progress_pct=s.progress_pct,
            state='FAILED',
        )
        effects = {
            'event': 'ERROR',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'error_syncing':
        if not (('SYNCING' == s.state)):
            return StepResult(ok=False, error='guard failed for error_syncing')
        # Compute updates (simultaneous)
        new_state = State(
            has_error=True,
            progress_pct=s.progress_pct,
            state='FAILED',
        )
        effects = {
            'event': 'ERROR',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'error_verifying':
        if not (('VERIFYING' == s.state)):
            return StepResult(ok=False, error='guard failed for error_verifying')
        # Compute updates (simultaneous)
        new_state = State(
            has_error=True,
            progress_pct=s.progress_pct,
            state='FAILED',
        )
        effects = {
            'event': 'ERROR',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'reset_from_complete':
        if not (('COMPLETE' == s.state)):
            return StepResult(ok=False, error='guard failed for reset_from_complete')
        # Compute updates (simultaneous)
        new_state = State(
            has_error=False,
            progress_pct=0,
            state='IDLE',
        )
        effects = {
            'event': 'RESET',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'reset_from_failed':
        if not (('FAILED' == s.state)):
            return StepResult(ok=False, error='guard failed for reset_from_failed')
        # Compute updates (simultaneous)
        new_state = State(
            has_error=False,
            progress_pct=0,
            state='IDLE',
        )
        effects = {
            'event': 'RESET',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'start_sync':
        if not (('IDLE' == s.state)):
            return StepResult(ok=False, error='guard failed for start_sync')
        # Compute updates (simultaneous)
        new_state = State(
            has_error=False,
            progress_pct=s.progress_pct,
            state='COMPARING',
        )
        effects = {
            'event': 'START',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'sync_progress':
        if not (((s.progress_pct < 90) and ('SYNCING' == s.state))):
            return StepResult(ok=False, error='guard failed for sync_progress')
        # Compute updates (simultaneous)
        new_state = State(
            has_error=s.has_error,
            progress_pct=(10 + s.progress_pct),
            state=s.state,
        )
        effects = {
            'event': 'SYNC_DONE',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'sync_to_verify':
        if not ((('SYNCING' == s.state) and (s.progress_pct >= 90))):
            return StepResult(ok=False, error='guard failed for sync_to_verify')
        # Compute updates (simultaneous)
        new_state = State(
            has_error=s.has_error,
            progress_pct=95,
            state='VERIFYING',
        )
        effects = {
            'event': 'SYNC_DONE',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'verify_done':
        if not (('VERIFYING' == s.state)):
            return StepResult(ok=False, error='guard failed for verify_done')
        # Compute updates (simultaneous)
        new_state = State(
            has_error=s.has_error,
            progress_pct=100,
            state='COMPLETE',
        )
        effects = {
            'event': 'VERIFY_DONE',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    else:
        return StepResult(ok=False, error=f'unknown action: {cmd.tag}')


# === Hypothesis test scaffolding ===
# Uncomment and install hypothesis to use property-based testing

# from hypothesis import given, strategies as st
# from hypothesis.stateful import RuleBasedStateMachine, rule, initialize
#
# class ModelStateMachine(RuleBasedStateMachine):
#     def __init__(self):
#         super().__init__()
#         self.state = init_state()
#
#     @initialize()
#     def init(self):
#         self.state = init_state()
#         ok, _ = check_invariants(self.state)
#         assert ok, 'init violates invariants'
#
#     # @rule()
#     # def compare_done(self, ):
#     #     cmd = Command(tag='compare_done', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def error_comparing(self, ):
#     #     cmd = Command(tag='error_comparing', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def error_syncing(self, ):
#     #     cmd = Command(tag='error_syncing', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def error_verifying(self, ):
#     #     cmd = Command(tag='error_verifying', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def reset_from_complete(self, ):
#     #     cmd = Command(tag='reset_from_complete', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def reset_from_failed(self, ):
#     #     cmd = Command(tag='reset_from_failed', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def start_sync(self, ):
#     #     cmd = Command(tag='start_sync', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def sync_progress(self, ):
#     #     cmd = Command(tag='sync_progress', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def sync_to_verify(self, ):
#     #     cmd = Command(tag='sync_to_verify', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def verify_done(self, ):
#     #     cmd = Command(tag='verify_done', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
# TestModel = ModelStateMachine.TestCase


def replay_trace(commands: list[tuple[str, dict[str, Any]]]) -> list[StepResult]:
    """Replay a trace of commands and return results."""
    results: list[StepResult] = []
    s = init_state()
    for tag, args in commands:
        cmd = Command(tag=tag, args=args)
        result = step(s, cmd)
        results.append(result)
        if result.ok and result.state is not None:
            s = result.state
        else:
            break
    return results


if __name__ == '__main__':
    # Quick sanity check
    s0 = init_state()
    ok, failed = check_invariants(s0)
    print(f'Initial state: {s0}')
    print(f'Invariants OK: {ok}')
    if not ok:
        print(f'  Failed: {failed}')
