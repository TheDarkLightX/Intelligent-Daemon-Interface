"""
Auto-generated Python reference model for: replay_protection
IR hash: sha256:5aa2fb75741058f5c6972ab82745444d1af8b3546e63648c6ba3308ca62acc91

Generated by ESSO (Evolutionary Spec Search Optimizer)

This file is standalone and has no ESSO dependencies.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Literal, Mapping


@dataclass(frozen=True)
class State:
    """Model state."""
    last_timestamp: int
    peer_cap: int
    peer_count: int


@dataclass(frozen=True)
class Command:
    """Command to execute."""
    tag: Literal('accept_message', 'add_new_peer', 'evict_peer', 'reject_at_cap', 'reject_replay')
    args: Mapping[str, Any]


@dataclass(frozen=True)
class StepResult:
    """Result of a step execution."""
    ok: bool
    state: State | None = None
    effects: Mapping[str, Any] | None = None
    error: str | None = None


def init_state() -> State:
    """Return the initial state."""
    return State(
        last_timestamp=0,
        peer_cap=10000,
        peer_count=0,
    )


def check_invariants(s: State) -> tuple[bool, str | None]:
    """Check all invariants. Returns (ok, first_failed_id)."""
    if not (isinstance(s.last_timestamp, int) and not isinstance(s.last_timestamp, bool) and 0 <= s.last_timestamp <= 1000000):
        return False, 'domain_last_timestamp'
    if not (isinstance(s.peer_cap, int) and not isinstance(s.peer_cap, bool) and 1 <= s.peer_cap <= 10000):
        return False, 'domain_peer_cap'
    if not (isinstance(s.peer_count, int) and not isinstance(s.peer_count, bool) and 0 <= s.peer_count <= 10000):
        return False, 'domain_peer_count'
    if not ((s.peer_count <= s.peer_cap)):
        return False, 'peer_count_bounded'
    if not ((s.peer_count >= 0)):
        return False, 'peer_count_non_negative'
    if not ((s.last_timestamp >= 0)):
        return False, 'timestamp_non_negative'
    return True, None


def step(s: State, cmd: Command) -> StepResult:
    """Execute a step. Returns StepResult."""
    # Check pre-state invariants
    ok, failed = check_invariants(s)
    if not ok:
        return StepResult(ok=False, error=f'pre-invariant violated: {failed}')

    if cmd.tag == 'accept_message':
        if 'msg_timestamp' not in cmd.args or not (isinstance(cmd.args['msg_timestamp'], int) and not isinstance(cmd.args['msg_timestamp'], bool) and 0 <= cmd.args['msg_timestamp'] <= 1000000):
            return StepResult(ok=False, error='invalid param msg_timestamp')
        if not ((cmd.args['msg_timestamp'] > s.last_timestamp)):
            return StepResult(ok=False, error='guard failed for accept_message')
        # Compute updates (simultaneous)
        new_state = State(
            last_timestamp=cmd.args['msg_timestamp'],
            peer_cap=s.peer_cap,
            peer_count=s.peer_count,
        )
        effects = {
            'message_accepted': True,
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'add_new_peer':
        if not ((s.peer_count < s.peer_cap)):
            return StepResult(ok=False, error='guard failed for add_new_peer')
        # Compute updates (simultaneous)
        new_state = State(
            last_timestamp=s.last_timestamp,
            peer_cap=s.peer_cap,
            peer_count=(1 + s.peer_count),
        )
        effects = {
            'message_accepted': True,
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'evict_peer':
        if not ((s.peer_count > 0)):
            return StepResult(ok=False, error='guard failed for evict_peer')
        # Compute updates (simultaneous)
        new_state = State(
            last_timestamp=s.last_timestamp,
            peer_cap=s.peer_cap,
            peer_count=(s.peer_count - 1),
        )
        effects = {
            'message_accepted': True,
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'reject_at_cap':
        if not ((s.peer_count >= s.peer_cap)):
            return StepResult(ok=False, error='guard failed for reject_at_cap')
        # Compute updates (simultaneous)
        new_state = State(
            last_timestamp=s.last_timestamp,
            peer_cap=s.peer_cap,
            peer_count=s.peer_count,
        )
        effects = {
            'message_accepted': False,
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'reject_replay':
        if 'msg_timestamp' not in cmd.args or not (isinstance(cmd.args['msg_timestamp'], int) and not isinstance(cmd.args['msg_timestamp'], bool) and 0 <= cmd.args['msg_timestamp'] <= 1000000):
            return StepResult(ok=False, error='invalid param msg_timestamp')
        if not ((cmd.args['msg_timestamp'] <= s.last_timestamp)):
            return StepResult(ok=False, error='guard failed for reject_replay')
        # Compute updates (simultaneous)
        new_state = State(
            last_timestamp=s.last_timestamp,
            peer_cap=s.peer_cap,
            peer_count=s.peer_count,
        )
        effects = {
            'message_accepted': False,
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    else:
        return StepResult(ok=False, error=f'unknown action: {cmd.tag}')


# === Hypothesis test scaffolding ===
# Uncomment and install hypothesis to use property-based testing

# from hypothesis import given, strategies as st
# from hypothesis.stateful import RuleBasedStateMachine, rule, initialize
#
# class ModelStateMachine(RuleBasedStateMachine):
#     def __init__(self):
#         super().__init__()
#         self.state = init_state()
#
#     @initialize()
#     def init(self):
#         self.state = init_state()
#         ok, _ = check_invariants(self.state)
#         assert ok, 'init violates invariants'
#
#     # @rule(msg_timestamp=st.integers())
#     # def accept_message(self, msg_timestamp):
#     #     cmd = Command(tag='accept_message', args={'msg_timestamp': msg_timestamp})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def add_new_peer(self, ):
#     #     cmd = Command(tag='add_new_peer', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def evict_peer(self, ):
#     #     cmd = Command(tag='evict_peer', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def reject_at_cap(self, ):
#     #     cmd = Command(tag='reject_at_cap', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule(msg_timestamp=st.integers())
#     # def reject_replay(self, msg_timestamp):
#     #     cmd = Command(tag='reject_replay', args={'msg_timestamp': msg_timestamp})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
# TestModel = ModelStateMachine.TestCase


def replay_trace(commands: list[tuple[str, dict[str, Any]]]) -> list[StepResult]:
    """Replay a trace of commands and return results."""
    results: list[StepResult] = []
    s = init_state()
    for tag, args in commands:
        cmd = Command(tag=tag, args=args)
        result = step(s, cmd)
        results.append(result)
        if result.ok and result.state is not None:
            s = result.state
        else:
            break
    return results


if __name__ == '__main__':
    # Quick sanity check
    s0 = init_state()
    ok, failed = check_invariants(s0)
    print(f'Initial state: {s0}')
    print(f'Invariants OK: {ok}')
    if not ok:
        print(f'  Failed: {failed}')
