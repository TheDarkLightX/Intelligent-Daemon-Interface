"""
Auto-generated Python reference model for: mempool_lifecycle
IR hash: sha256:878196fbe560fe6b8642ca045685bac3521575085c1f66e566738cd0a6e8bffb

Generated by ESSO (Evolutionary Spec Search Optimizer)

This file is standalone and has no ESSO dependencies.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Literal, Mapping


# Domain enums
STATUS_SYMBOLS = ('ACTIVE', 'FULL', 'PAUSED', 'DRAINING')


@dataclass(frozen=True)
class State:
    """Model state."""
    count: int
    max_size: int
    status: str


@dataclass(frozen=True)
class Command:
    """Command to execute."""
    tag: Literal('add_active', 'add_fill', 'drain', 'pause_active', 'pause_full', 'remove_active', 'remove_draining', 'remove_full_open', 'remove_full_stay', 'remove_paused', 'resume_active', 'resume_full')
    args: Mapping[str, Any]


@dataclass(frozen=True)
class StepResult:
    """Result of a step execution."""
    ok: bool
    state: State | None = None
    effects: Mapping[str, Any] | None = None
    error: str | None = None


def init_state() -> State:
    """Return the initial state."""
    return State(
        count=0,
        max_size=1,
        status='ACTIVE',
    )


def check_invariants(s: State) -> tuple[bool, str | None]:
    """Check all invariants. Returns (ok, first_failed_id)."""
    if not (isinstance(s.count, int) and not isinstance(s.count, bool) and 0 <= s.count <= 1000000):
        return False, 'domain_count'
    if not (isinstance(s.max_size, int) and not isinstance(s.max_size, bool) and 1 <= s.max_size <= 1000000):
        return False, 'domain_max_size'
    if not (s.status in ('ACTIVE', 'FULL', 'PAUSED', 'DRAINING')):
        return False, 'domain_status'
    if not ((('ACTIVE' != s.status) or (s.count < s.max_size))):
        return False, 'active_count'
    if not ((s.count <= 1000000)):
        return False, 'bounded_count'
    if not ((s.count >= 0)):
        return False, 'count_non_negative'
    if not ((('FULL' != s.status) or (s.count >= s.max_size))):
        return False, 'full_count'
    return True, None


def step(s: State, cmd: Command) -> StepResult:
    """Execute a step. Returns StepResult."""
    # Check pre-state invariants
    ok, failed = check_invariants(s)
    if not ok:
        return StepResult(ok=False, error=f'pre-invariant violated: {failed}')

    if cmd.tag == 'add_active':
        if not ((((1 + s.count) < s.max_size) and ('ACTIVE' == s.status))):
            return StepResult(ok=False, error='guard failed for add_active')
        # Compute updates (simultaneous)
        new_state = State(
            count=(1 + s.count),
            max_size=s.max_size,
            status='ACTIVE',
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'add_fill':
        if not ((('ACTIVE' == s.status) and ((1 + s.count) == s.max_size))):
            return StepResult(ok=False, error='guard failed for add_fill')
        # Compute updates (simultaneous)
        new_state = State(
            count=(1 + s.count),
            max_size=s.max_size,
            status='FULL',
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'drain':
        if not (('DRAINING' != s.status)):
            return StepResult(ok=False, error='guard failed for drain')
        # Compute updates (simultaneous)
        new_state = State(
            count=s.count,
            max_size=s.max_size,
            status='DRAINING',
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'pause_active':
        if not (('ACTIVE' == s.status)):
            return StepResult(ok=False, error='guard failed for pause_active')
        # Compute updates (simultaneous)
        new_state = State(
            count=s.count,
            max_size=s.max_size,
            status='PAUSED',
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'pause_full':
        if not (('FULL' == s.status)):
            return StepResult(ok=False, error='guard failed for pause_full')
        # Compute updates (simultaneous)
        new_state = State(
            count=s.count,
            max_size=s.max_size,
            status='PAUSED',
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'remove_active':
        if not ((('ACTIVE' == s.status) and (s.count > 0))):
            return StepResult(ok=False, error='guard failed for remove_active')
        # Compute updates (simultaneous)
        new_state = State(
            count=(s.count - 1),
            max_size=s.max_size,
            status='ACTIVE',
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'remove_draining':
        if not ((('DRAINING' == s.status) and (s.count > 0))):
            return StepResult(ok=False, error='guard failed for remove_draining')
        # Compute updates (simultaneous)
        new_state = State(
            count=(s.count - 1),
            max_size=s.max_size,
            status='DRAINING',
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'remove_full_open':
        if not ((((s.count - 1) < s.max_size) and ('FULL' == s.status))):
            return StepResult(ok=False, error='guard failed for remove_full_open')
        # Compute updates (simultaneous)
        new_state = State(
            count=(s.count - 1),
            max_size=s.max_size,
            status='ACTIVE',
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'remove_full_stay':
        if not ((('FULL' == s.status) and ((s.count - 1) >= s.max_size))):
            return StepResult(ok=False, error='guard failed for remove_full_stay')
        # Compute updates (simultaneous)
        new_state = State(
            count=(s.count - 1),
            max_size=s.max_size,
            status='FULL',
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'remove_paused':
        if not ((('PAUSED' == s.status) and (s.count > 0))):
            return StepResult(ok=False, error='guard failed for remove_paused')
        # Compute updates (simultaneous)
        new_state = State(
            count=(s.count - 1),
            max_size=s.max_size,
            status='PAUSED',
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'resume_active':
        if not (((s.count < s.max_size) and ('PAUSED' == s.status))):
            return StepResult(ok=False, error='guard failed for resume_active')
        # Compute updates (simultaneous)
        new_state = State(
            count=s.count,
            max_size=s.max_size,
            status='ACTIVE',
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'resume_full':
        if not ((('PAUSED' == s.status) and (s.count >= s.max_size))):
            return StepResult(ok=False, error='guard failed for resume_full')
        # Compute updates (simultaneous)
        new_state = State(
            count=s.count,
            max_size=s.max_size,
            status='FULL',
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    else:
        return StepResult(ok=False, error=f'unknown action: {cmd.tag}')


# === Hypothesis test scaffolding ===
# Uncomment and install hypothesis to use property-based testing

# from hypothesis import given, strategies as st
# from hypothesis.stateful import RuleBasedStateMachine, rule, initialize
#
# class ModelStateMachine(RuleBasedStateMachine):
#     def __init__(self):
#         super().__init__()
#         self.state = init_state()
#
#     @initialize()
#     def init(self):
#         self.state = init_state()
#         ok, _ = check_invariants(self.state)
#         assert ok, 'init violates invariants'
#
#     # @rule()
#     # def add_active(self, ):
#     #     cmd = Command(tag='add_active', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def add_fill(self, ):
#     #     cmd = Command(tag='add_fill', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def drain(self, ):
#     #     cmd = Command(tag='drain', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def pause_active(self, ):
#     #     cmd = Command(tag='pause_active', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def pause_full(self, ):
#     #     cmd = Command(tag='pause_full', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def remove_active(self, ):
#     #     cmd = Command(tag='remove_active', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def remove_draining(self, ):
#     #     cmd = Command(tag='remove_draining', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def remove_full_open(self, ):
#     #     cmd = Command(tag='remove_full_open', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def remove_full_stay(self, ):
#     #     cmd = Command(tag='remove_full_stay', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def remove_paused(self, ):
#     #     cmd = Command(tag='remove_paused', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def resume_active(self, ):
#     #     cmd = Command(tag='resume_active', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def resume_full(self, ):
#     #     cmd = Command(tag='resume_full', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
# TestModel = ModelStateMachine.TestCase


def replay_trace(commands: list[tuple[str, dict[str, Any]]]) -> list[StepResult]:
    """Replay a trace of commands and return results."""
    results: list[StepResult] = []
    s = init_state()
    for tag, args in commands:
        cmd = Command(tag=tag, args=args)
        result = step(s, cmd)
        results.append(result)
        if result.ok and result.state is not None:
            s = result.state
        else:
            break
    return results


if __name__ == '__main__':
    # Quick sanity check
    s0 = init_state()
    ok, failed = check_invariants(s0)
    print(f'Initial state: {s0}')
    print(f'Invariants OK: {ok}')
    if not ok:
        print(f'  Failed: {failed}')
