"""
Auto-generated Python reference model for: peer_tier
IR hash: sha256:34c54527730a4c35ae90fe2aa00b99d7750ca7ef960e7dfc11401bd11230084c

Generated by ESSO (Evolutionary Spec Search Optimizer)

This file is standalone and has no ESSO dependencies.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Literal, Mapping


# Domain enums
TIER_SYMBOLS = ('COLD', 'PASSIVE', 'ACTIVE', 'PROMOTING', 'DEMOTING')


@dataclass(frozen=True)
class State:
    """Model state."""
    active_threshold: int
    connected: bool
    demote_threshold: int
    score: int
    tier: str


@dataclass(frozen=True)
class Command:
    """Command to execute."""
    tag: Literal('cancel_demote', 'cancel_promote', 'complete_demote', 'complete_promote', 'connect_cold', 'disconnect', 'score_decrease', 'score_increase', 'start_demote', 'start_promote')
    args: Mapping[str, Any]


@dataclass(frozen=True)
class StepResult:
    """Result of a step execution."""
    ok: bool
    state: State | None = None
    effects: Mapping[str, Any] | None = None
    error: str | None = None


def init_state() -> State:
    """Return the initial state."""
    return State(
        active_threshold=50,
        connected=False,
        demote_threshold=0,
        score=0,
        tier='COLD',
    )


def check_invariants(s: State) -> tuple[bool, str | None]:
    """Check all invariants. Returns (ok, first_failed_id)."""
    if not (isinstance(s.active_threshold, int) and not isinstance(s.active_threshold, bool) and 50 <= s.active_threshold <= 100):
        return False, 'domain_active_threshold'
    if not (isinstance(s.connected, bool)):
        return False, 'domain_connected'
    if not (isinstance(s.demote_threshold, int) and not isinstance(s.demote_threshold, bool) and 0 <= s.demote_threshold <= 50):
        return False, 'domain_demote_threshold'
    if not (isinstance(s.score, int) and not isinstance(s.score, bool) and 0 <= s.score <= 100):
        return False, 'domain_score'
    if not (s.tier in ('COLD', 'PASSIVE', 'ACTIVE', 'PROMOTING', 'DEMOTING')):
        return False, 'domain_tier'
    if not ((('COLD' != s.tier) or (False == s.connected))):
        return False, 'cold_disconnected'
    if not ((('COLD' != s.tier) or (False == s.connected))):
        return False, 'connected_not_cold'
    if not (((s.score <= 100) and (s.score >= 0))):
        return False, 'score_bounded'
    if not ((s.demote_threshold < s.active_threshold)):
        return False, 'threshold_order'
    return True, None


def step(s: State, cmd: Command) -> StepResult:
    """Execute a step. Returns StepResult."""
    # Check pre-state invariants
    ok, failed = check_invariants(s)
    if not ok:
        return StepResult(ok=False, error=f'pre-invariant violated: {failed}')

    if cmd.tag == 'cancel_demote':
        if not (('DEMOTING' == s.tier)):
            return StepResult(ok=False, error='guard failed for cancel_demote')
        # Compute updates (simultaneous)
        new_state = State(
            active_threshold=s.active_threshold,
            connected=s.connected,
            demote_threshold=s.demote_threshold,
            score=s.score,
            tier='ACTIVE',
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'cancel_promote':
        if not (('PROMOTING' == s.tier)):
            return StepResult(ok=False, error='guard failed for cancel_promote')
        # Compute updates (simultaneous)
        new_state = State(
            active_threshold=s.active_threshold,
            connected=s.connected,
            demote_threshold=s.demote_threshold,
            score=s.score,
            tier='PASSIVE',
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'complete_demote':
        if not (('DEMOTING' == s.tier)):
            return StepResult(ok=False, error='guard failed for complete_demote')
        # Compute updates (simultaneous)
        new_state = State(
            active_threshold=s.active_threshold,
            connected=s.connected,
            demote_threshold=s.demote_threshold,
            score=s.score,
            tier='PASSIVE',
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'complete_promote':
        if not (('PROMOTING' == s.tier)):
            return StepResult(ok=False, error='guard failed for complete_promote')
        # Compute updates (simultaneous)
        new_state = State(
            active_threshold=s.active_threshold,
            connected=s.connected,
            demote_threshold=s.demote_threshold,
            score=s.score,
            tier='ACTIVE',
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'connect_cold':
        if not (((False == s.connected) and ('COLD' == s.tier))):
            return StepResult(ok=False, error='guard failed for connect_cold')
        # Compute updates (simultaneous)
        new_state = State(
            active_threshold=s.active_threshold,
            connected=True,
            demote_threshold=s.demote_threshold,
            score=50,
            tier='PASSIVE',
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'disconnect':
        if not ((True == s.connected)):
            return StepResult(ok=False, error='guard failed for disconnect')
        # Compute updates (simultaneous)
        new_state = State(
            active_threshold=s.active_threshold,
            connected=False,
            demote_threshold=s.demote_threshold,
            score=0,
            tier='COLD',
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'score_decrease':
        if not (((True == s.connected) and (s.score > 0))):
            return StepResult(ok=False, error='guard failed for score_decrease')
        # Compute updates (simultaneous)
        new_state = State(
            active_threshold=s.active_threshold,
            connected=s.connected,
            demote_threshold=s.demote_threshold,
            score=(s.score - 1),
            tier=s.tier,
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'score_increase':
        if not (((s.score < 100) and (True == s.connected))):
            return StepResult(ok=False, error='guard failed for score_increase')
        # Compute updates (simultaneous)
        new_state = State(
            active_threshold=s.active_threshold,
            connected=s.connected,
            demote_threshold=s.demote_threshold,
            score=(1 + s.score),
            tier=s.tier,
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'start_demote':
        if not (((s.score <= s.demote_threshold) and ('ACTIVE' == s.tier))):
            return StepResult(ok=False, error='guard failed for start_demote')
        # Compute updates (simultaneous)
        new_state = State(
            active_threshold=s.active_threshold,
            connected=s.connected,
            demote_threshold=s.demote_threshold,
            score=s.score,
            tier='DEMOTING',
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'start_promote':
        if not ((('PASSIVE' == s.tier) and (s.score >= s.active_threshold))):
            return StepResult(ok=False, error='guard failed for start_promote')
        # Compute updates (simultaneous)
        new_state = State(
            active_threshold=s.active_threshold,
            connected=s.connected,
            demote_threshold=s.demote_threshold,
            score=s.score,
            tier='PROMOTING',
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    else:
        return StepResult(ok=False, error=f'unknown action: {cmd.tag}')


# === Hypothesis test scaffolding ===
# Uncomment and install hypothesis to use property-based testing

# from hypothesis import given, strategies as st
# from hypothesis.stateful import RuleBasedStateMachine, rule, initialize
#
# class ModelStateMachine(RuleBasedStateMachine):
#     def __init__(self):
#         super().__init__()
#         self.state = init_state()
#
#     @initialize()
#     def init(self):
#         self.state = init_state()
#         ok, _ = check_invariants(self.state)
#         assert ok, 'init violates invariants'
#
#     # @rule()
#     # def cancel_demote(self, ):
#     #     cmd = Command(tag='cancel_demote', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def cancel_promote(self, ):
#     #     cmd = Command(tag='cancel_promote', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def complete_demote(self, ):
#     #     cmd = Command(tag='complete_demote', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def complete_promote(self, ):
#     #     cmd = Command(tag='complete_promote', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def connect_cold(self, ):
#     #     cmd = Command(tag='connect_cold', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def disconnect(self, ):
#     #     cmd = Command(tag='disconnect', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def score_decrease(self, ):
#     #     cmd = Command(tag='score_decrease', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def score_increase(self, ):
#     #     cmd = Command(tag='score_increase', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def start_demote(self, ):
#     #     cmd = Command(tag='start_demote', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def start_promote(self, ):
#     #     cmd = Command(tag='start_promote', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
# TestModel = ModelStateMachine.TestCase


def replay_trace(commands: list[tuple[str, dict[str, Any]]]) -> list[StepResult]:
    """Replay a trace of commands and return results."""
    results: list[StepResult] = []
    s = init_state()
    for tag, args in commands:
        cmd = Command(tag=tag, args=args)
        result = step(s, cmd)
        results.append(result)
        if result.ok and result.state is not None:
            s = result.state
        else:
            break
    return results


if __name__ == '__main__':
    # Quick sanity check
    s0 = init_state()
    ok, failed = check_invariants(s0)
    print(f'Initial state: {s0}')
    print(f'Invariants OK: {ok}')
    if not ok:
        print(f'  Failed: {failed}')
