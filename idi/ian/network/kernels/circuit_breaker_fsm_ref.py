"""
Auto-generated Python reference model for: circuit_breaker_fsm
IR hash: sha256:dabc7a6e12135320125585477e727e6b11d1ea8d6c780586f18fa208d4860747

Generated by ESSO (Evolutionary Spec Search Optimizer)

This file is standalone and has no ESSO dependencies.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Literal, Mapping


# Domain enums
STATE_SYMBOLS = ('CLOSED', 'OPEN', 'HALF_OPEN')


@dataclass(frozen=True)
class State:
    """Model state."""
    consecutive_failures: int
    consecutive_successes: int
    failure_threshold: int
    state: str
    success_threshold: int


@dataclass(frozen=True)
class Command:
    """Command to execute."""
    tag: Literal('failure_closed_no_trip', 'failure_closed_trip', 'failure_half_open_trip', 'manual_reset', 'success_closed', 'success_half_open_close', 'success_half_open_no_close', 'timeout_to_half_open')
    args: Mapping[str, Any]


@dataclass(frozen=True)
class StepResult:
    """Result of a step execution."""
    ok: bool
    state: State | None = None
    effects: Mapping[str, Any] | None = None
    error: str | None = None


def init_state() -> State:
    """Return the initial state."""
    return State(
        consecutive_failures=0,
        consecutive_successes=0,
        failure_threshold=5,
        state='CLOSED',
        success_threshold=3,
    )


def check_invariants(s: State) -> tuple[bool, str | None]:
    """Check all invariants. Returns (ok, first_failed_id)."""
    if not (isinstance(s.consecutive_failures, int) and not isinstance(s.consecutive_failures, bool) and 0 <= s.consecutive_failures <= 10):
        return False, 'domain_consecutive_failures'
    if not (isinstance(s.consecutive_successes, int) and not isinstance(s.consecutive_successes, bool) and 0 <= s.consecutive_successes <= 5):
        return False, 'domain_consecutive_successes'
    if not (isinstance(s.failure_threshold, int) and not isinstance(s.failure_threshold, bool) and 1 <= s.failure_threshold <= 10):
        return False, 'domain_failure_threshold'
    if not (s.state in ('CLOSED', 'OPEN', 'HALF_OPEN')):
        return False, 'domain_state'
    if not (isinstance(s.success_threshold, int) and not isinstance(s.success_threshold, bool) and 1 <= s.success_threshold <= 5):
        return False, 'domain_success_threshold'
    if not (((not ('CLOSED' == s.state)) or (s.consecutive_failures < s.failure_threshold))):
        return False, 'closed_under_threshold'
    if not (((not ('HALF_OPEN' == s.state)) or (0 == s.consecutive_failures))):
        return False, 'half_open_clean_start'
    return True, None


def step(s: State, cmd: Command) -> StepResult:
    """Execute a step. Returns StepResult."""
    # Check pre-state invariants
    ok, failed = check_invariants(s)
    if not ok:
        return StepResult(ok=False, error=f'pre-invariant violated: {failed}')

    if cmd.tag == 'failure_closed_no_trip':
        if not ((((1 + s.consecutive_failures) < s.failure_threshold) and ('CLOSED' == s.state))):
            return StepResult(ok=False, error='guard failed for failure_closed_no_trip')
        # Compute updates (simultaneous)
        new_state = State(
            consecutive_failures=(1 + s.consecutive_failures),
            consecutive_successes=0,
            failure_threshold=s.failure_threshold,
            state=s.state,
            success_threshold=s.success_threshold,
        )
        effects = {
            'event': 'FAILURE',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'failure_closed_trip':
        if not ((('CLOSED' == s.state) and ((1 + s.consecutive_failures) >= s.failure_threshold))):
            return StepResult(ok=False, error='guard failed for failure_closed_trip')
        # Compute updates (simultaneous)
        new_state = State(
            consecutive_failures=(1 + s.consecutive_failures),
            consecutive_successes=0,
            failure_threshold=s.failure_threshold,
            state='OPEN',
            success_threshold=s.success_threshold,
        )
        effects = {
            'event': 'FAILURE',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'failure_half_open_trip':
        if not (('HALF_OPEN' == s.state)):
            return StepResult(ok=False, error='guard failed for failure_half_open_trip')
        # Compute updates (simultaneous)
        new_state = State(
            consecutive_failures=1,
            consecutive_successes=0,
            failure_threshold=s.failure_threshold,
            state='OPEN',
            success_threshold=s.success_threshold,
        )
        effects = {
            'event': 'FAILURE',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'manual_reset':
        if not (True):
            return StepResult(ok=False, error='guard failed for manual_reset')
        # Compute updates (simultaneous)
        new_state = State(
            consecutive_failures=0,
            consecutive_successes=0,
            failure_threshold=s.failure_threshold,
            state='CLOSED',
            success_threshold=s.success_threshold,
        )
        effects = {
            'event': 'RESET',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'success_closed':
        if not (((s.consecutive_successes < 5) and ('CLOSED' == s.state))):
            return StepResult(ok=False, error='guard failed for success_closed')
        # Compute updates (simultaneous)
        new_state = State(
            consecutive_failures=0,
            consecutive_successes=(1 + s.consecutive_successes),
            failure_threshold=s.failure_threshold,
            state=s.state,
            success_threshold=s.success_threshold,
        )
        effects = {
            'event': 'SUCCESS',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'success_half_open_close':
        if not ((('HALF_OPEN' == s.state) and ((1 + s.consecutive_successes) >= s.success_threshold))):
            return StepResult(ok=False, error='guard failed for success_half_open_close')
        # Compute updates (simultaneous)
        new_state = State(
            consecutive_failures=0,
            consecutive_successes=0,
            failure_threshold=s.failure_threshold,
            state='CLOSED',
            success_threshold=s.success_threshold,
        )
        effects = {
            'event': 'SUCCESS',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'success_half_open_no_close':
        if not ((((1 + s.consecutive_successes) < s.success_threshold) and ('HALF_OPEN' == s.state))):
            return StepResult(ok=False, error='guard failed for success_half_open_no_close')
        # Compute updates (simultaneous)
        new_state = State(
            consecutive_failures=s.consecutive_failures,
            consecutive_successes=(1 + s.consecutive_successes),
            failure_threshold=s.failure_threshold,
            state=s.state,
            success_threshold=s.success_threshold,
        )
        effects = {
            'event': 'SUCCESS',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'timeout_to_half_open':
        if not (('OPEN' == s.state)):
            return StepResult(ok=False, error='guard failed for timeout_to_half_open')
        # Compute updates (simultaneous)
        new_state = State(
            consecutive_failures=0,
            consecutive_successes=0,
            failure_threshold=s.failure_threshold,
            state='HALF_OPEN',
            success_threshold=s.success_threshold,
        )
        effects = {
            'event': 'TIMEOUT',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    else:
        return StepResult(ok=False, error=f'unknown action: {cmd.tag}')


# === Hypothesis test scaffolding ===
# Uncomment and install hypothesis to use property-based testing

# from hypothesis import given, strategies as st
# from hypothesis.stateful import RuleBasedStateMachine, rule, initialize
#
# class ModelStateMachine(RuleBasedStateMachine):
#     def __init__(self):
#         super().__init__()
#         self.state = init_state()
#
#     @initialize()
#     def init(self):
#         self.state = init_state()
#         ok, _ = check_invariants(self.state)
#         assert ok, 'init violates invariants'
#
#     # @rule()
#     # def failure_closed_no_trip(self, ):
#     #     cmd = Command(tag='failure_closed_no_trip', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def failure_closed_trip(self, ):
#     #     cmd = Command(tag='failure_closed_trip', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def failure_half_open_trip(self, ):
#     #     cmd = Command(tag='failure_half_open_trip', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def manual_reset(self, ):
#     #     cmd = Command(tag='manual_reset', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def success_closed(self, ):
#     #     cmd = Command(tag='success_closed', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def success_half_open_close(self, ):
#     #     cmd = Command(tag='success_half_open_close', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def success_half_open_no_close(self, ):
#     #     cmd = Command(tag='success_half_open_no_close', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def timeout_to_half_open(self, ):
#     #     cmd = Command(tag='timeout_to_half_open', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
# TestModel = ModelStateMachine.TestCase


def replay_trace(commands: list[tuple[str, dict[str, Any]]]) -> list[StepResult]:
    """Replay a trace of commands and return results."""
    results: list[StepResult] = []
    s = init_state()
    for tag, args in commands:
        cmd = Command(tag=tag, args=args)
        result = step(s, cmd)
        results.append(result)
        if result.ok and result.state is not None:
            s = result.state
        else:
            break
    return results


if __name__ == '__main__':
    # Quick sanity check
    s0 = init_state()
    ok, failed = check_invariants(s0)
    print(f'Initial state: {s0}')
    print(f'Invariants OK: {ok}')
    if not ok:
        print(f'  Failed: {failed}')
