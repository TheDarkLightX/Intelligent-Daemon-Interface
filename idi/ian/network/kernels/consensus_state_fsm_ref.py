"""
Auto-generated Python reference model for: consensus_state_fsm
IR hash: sha256:e294dda6ec1e9acaae2899f6b452cc8bca87d20a31079e26f088867328741bcb

Generated by ESSO (Evolutionary Spec Search Optimizer)

This file is standalone and has no ESSO dependencies.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Literal, Mapping


# Domain enums
STATE_SYMBOLS = ('SYNCING', 'SYNCHRONIZED', 'DIVERGED', 'ISOLATED')


@dataclass(frozen=True)
class State:
    """Model state."""
    matching_peers: int
    min_peers: int
    peer_count: int
    quorum_fraction_den: int
    quorum_fraction_num: int
    state: str


@dataclass(frozen=True)
class Command:
    """Command to execute."""
    tag: Literal('diverged_start_sync', 'peer_diverge_decrease_from_sync_keep', 'peer_diverge_decrease_from_sync_lose', 'peer_diverge_decrease_non_sync', 'peer_matches_increase', 'peers_join_become_syncing', 'peers_join_steady', 'peers_join_still_isolated', 'peers_leave_become_isolated', 'peers_leave_matching', 'peers_leave_non_matching', 'state_diverge', 'sync_complete_become_synchronized')
    args: Mapping[str, Any]


@dataclass(frozen=True)
class StepResult:
    """Result of a step execution."""
    ok: bool
    state: State | None = None
    effects: Mapping[str, Any] | None = None
    error: str | None = None


def init_state() -> State:
    """Return the initial state."""
    return State(
        matching_peers=0,
        min_peers=2,
        peer_count=0,
        quorum_fraction_den=3,
        quorum_fraction_num=2,
        state='ISOLATED',
    )


def check_invariants(s: State) -> tuple[bool, str | None]:
    """Check all invariants. Returns (ok, first_failed_id)."""
    if not (isinstance(s.matching_peers, int) and not isinstance(s.matching_peers, bool) and 0 <= s.matching_peers <= 10):
        return False, 'domain_matching_peers'
    if not (isinstance(s.min_peers, int) and not isinstance(s.min_peers, bool) and 1 <= s.min_peers <= 5):
        return False, 'domain_min_peers'
    if not (isinstance(s.peer_count, int) and not isinstance(s.peer_count, bool) and 0 <= s.peer_count <= 10):
        return False, 'domain_peer_count'
    if not (isinstance(s.quorum_fraction_den, int) and not isinstance(s.quorum_fraction_den, bool) and 1 <= s.quorum_fraction_den <= 100):
        return False, 'domain_quorum_fraction_den'
    if not (isinstance(s.quorum_fraction_num, int) and not isinstance(s.quorum_fraction_num, bool) and 1 <= s.quorum_fraction_num <= 100):
        return False, 'domain_quorum_fraction_num'
    if not (s.state in ('SYNCING', 'SYNCHRONIZED', 'DIVERGED', 'ISOLATED')):
        return False, 'domain_state'
    if not (((not ('ISOLATED' == s.state)) or (s.peer_count < s.min_peers))):
        return False, 'isolated_no_peers'
    if not ((s.matching_peers <= s.peer_count)):
        return False, 'matching_le_peers'
    if not (((not ('SYNCHRONIZED' == s.state)) or ((s.matching_peers * s.quorum_fraction_den) >= (s.peer_count * s.quorum_fraction_num)))):
        return False, 'synchronized_has_quorum'
    return True, None


def step(s: State, cmd: Command) -> StepResult:
    """Execute a step. Returns StepResult."""
    # Check pre-state invariants
    ok, failed = check_invariants(s)
    if not ok:
        return StepResult(ok=False, error=f'pre-invariant violated: {failed}')

    if cmd.tag == 'diverged_start_sync':
        if not (('DIVERGED' == s.state)):
            return StepResult(ok=False, error='guard failed for diverged_start_sync')
        # Compute updates (simultaneous)
        new_state = State(
            matching_peers=s.matching_peers,
            min_peers=s.min_peers,
            peer_count=s.peer_count,
            quorum_fraction_den=s.quorum_fraction_den,
            quorum_fraction_num=s.quorum_fraction_num,
            state='SYNCING',
        )
        effects = {
            'event': 'SYNC_START',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'peer_diverge_decrease_from_sync_keep':
        if not ((('SYNCHRONIZED' == s.state) and (s.matching_peers > 0) and (((s.matching_peers - 1) * s.quorum_fraction_den) >= (s.peer_count * s.quorum_fraction_num)) and (s.peer_count >= s.min_peers))):
            return StepResult(ok=False, error='guard failed for peer_diverge_decrease_from_sync_keep')
        # Compute updates (simultaneous)
        new_state = State(
            matching_peers=(s.matching_peers - 1),
            min_peers=s.min_peers,
            peer_count=s.peer_count,
            quorum_fraction_den=s.quorum_fraction_den,
            quorum_fraction_num=s.quorum_fraction_num,
            state=s.state,
        )
        effects = {
            'event': 'STATE_DIVERGE',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'peer_diverge_decrease_from_sync_lose':
        if not (((((s.matching_peers - 1) * s.quorum_fraction_den) < (s.peer_count * s.quorum_fraction_num)) and ('SYNCHRONIZED' == s.state) and (s.matching_peers > 0) and (s.peer_count >= s.min_peers))):
            return StepResult(ok=False, error='guard failed for peer_diverge_decrease_from_sync_lose')
        # Compute updates (simultaneous)
        new_state = State(
            matching_peers=(s.matching_peers - 1),
            min_peers=s.min_peers,
            peer_count=s.peer_count,
            quorum_fraction_den=s.quorum_fraction_den,
            quorum_fraction_num=s.quorum_fraction_num,
            state='DIVERGED',
        )
        effects = {
            'event': 'STATE_DIVERGE',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'peer_diverge_decrease_non_sync':
        if not ((('SYNCHRONIZED' != s.state) and (s.matching_peers > 0) and (s.peer_count >= s.min_peers))):
            return StepResult(ok=False, error='guard failed for peer_diverge_decrease_non_sync')
        # Compute updates (simultaneous)
        new_state = State(
            matching_peers=(s.matching_peers - 1),
            min_peers=s.min_peers,
            peer_count=s.peer_count,
            quorum_fraction_den=s.quorum_fraction_den,
            quorum_fraction_num=s.quorum_fraction_num,
            state=s.state,
        )
        effects = {
            'event': 'STATE_DIVERGE',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'peer_matches_increase':
        if not (((s.matching_peers < s.peer_count) and (s.peer_count >= s.min_peers))):
            return StepResult(ok=False, error='guard failed for peer_matches_increase')
        # Compute updates (simultaneous)
        new_state = State(
            matching_peers=(1 + s.matching_peers),
            min_peers=s.min_peers,
            peer_count=s.peer_count,
            quorum_fraction_den=s.quorum_fraction_den,
            quorum_fraction_num=s.quorum_fraction_num,
            state=s.state,
        )
        effects = {
            'event': 'STATE_MATCH',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'peers_join_become_syncing':
        if not (((s.peer_count < 10) and ('ISOLATED' == s.state) and ((1 + s.peer_count) >= s.min_peers))):
            return StepResult(ok=False, error='guard failed for peers_join_become_syncing')
        # Compute updates (simultaneous)
        new_state = State(
            matching_peers=s.matching_peers,
            min_peers=s.min_peers,
            peer_count=(1 + s.peer_count),
            quorum_fraction_den=s.quorum_fraction_den,
            quorum_fraction_num=s.quorum_fraction_num,
            state='SYNCING',
        )
        effects = {
            'event': 'SYNC_START',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'peers_join_steady':
        if not ((('ISOLATED' != s.state) and (s.peer_count < 10))):
            return StepResult(ok=False, error='guard failed for peers_join_steady')
        # Compute updates (simultaneous)
        new_state = State(
            matching_peers=s.matching_peers,
            min_peers=s.min_peers,
            peer_count=(1 + s.peer_count),
            quorum_fraction_den=s.quorum_fraction_den,
            quorum_fraction_num=s.quorum_fraction_num,
            state=s.state,
        )
        effects = {
            'event': 'PEERS_JOINED',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'peers_join_still_isolated':
        if not ((((1 + s.peer_count) < s.min_peers) and (s.peer_count < 10) and ('ISOLATED' == s.state))):
            return StepResult(ok=False, error='guard failed for peers_join_still_isolated')
        # Compute updates (simultaneous)
        new_state = State(
            matching_peers=s.matching_peers,
            min_peers=s.min_peers,
            peer_count=(1 + s.peer_count),
            quorum_fraction_den=s.quorum_fraction_den,
            quorum_fraction_num=s.quorum_fraction_num,
            state=s.state,
        )
        effects = {
            'event': 'PEERS_JOINED',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'peers_leave_become_isolated':
        if not ((('ISOLATED' != s.state) and ((s.peer_count - 1) < s.min_peers) and (s.peer_count > 0))):
            return StepResult(ok=False, error='guard failed for peers_leave_become_isolated')
        # Compute updates (simultaneous)
        new_state = State(
            matching_peers=min((s.peer_count - 1), s.matching_peers),
            min_peers=s.min_peers,
            peer_count=(s.peer_count - 1),
            quorum_fraction_den=s.quorum_fraction_den,
            quorum_fraction_num=s.quorum_fraction_num,
            state='ISOLATED',
        )
        effects = {
            'event': 'PEERS_LEFT',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'peers_leave_matching':
        if not ((('ISOLATED' != s.state) and (s.matching_peers > 0) and (s.peer_count > s.min_peers))):
            return StepResult(ok=False, error='guard failed for peers_leave_matching')
        # Compute updates (simultaneous)
        new_state = State(
            matching_peers=(s.matching_peers - 1),
            min_peers=s.min_peers,
            peer_count=(s.peer_count - 1),
            quorum_fraction_den=s.quorum_fraction_den,
            quorum_fraction_num=s.quorum_fraction_num,
            state=s.state,
        )
        effects = {
            'event': 'PEERS_LEFT',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'peers_leave_non_matching':
        if not ((('ISOLATED' != s.state) and (s.peer_count > s.matching_peers) and (s.peer_count > s.min_peers))):
            return StepResult(ok=False, error='guard failed for peers_leave_non_matching')
        # Compute updates (simultaneous)
        new_state = State(
            matching_peers=s.matching_peers,
            min_peers=s.min_peers,
            peer_count=(s.peer_count - 1),
            quorum_fraction_den=s.quorum_fraction_den,
            quorum_fraction_num=s.quorum_fraction_num,
            state=s.state,
        )
        effects = {
            'event': 'PEERS_LEFT',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'state_diverge':
        if not ((((s.matching_peers * s.quorum_fraction_den) < (s.peer_count * s.quorum_fraction_num)) and ('SYNCHRONIZED' == s.state))):
            return StepResult(ok=False, error='guard failed for state_diverge')
        # Compute updates (simultaneous)
        new_state = State(
            matching_peers=s.matching_peers,
            min_peers=s.min_peers,
            peer_count=s.peer_count,
            quorum_fraction_den=s.quorum_fraction_den,
            quorum_fraction_num=s.quorum_fraction_num,
            state='DIVERGED',
        )
        effects = {
            'event': 'STATE_DIVERGE',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'sync_complete_become_synchronized':
        if not ((('SYNCING' == s.state) and ((s.matching_peers * s.quorum_fraction_den) >= (s.peer_count * s.quorum_fraction_num)))):
            return StepResult(ok=False, error='guard failed for sync_complete_become_synchronized')
        # Compute updates (simultaneous)
        new_state = State(
            matching_peers=s.matching_peers,
            min_peers=s.min_peers,
            peer_count=s.peer_count,
            quorum_fraction_den=s.quorum_fraction_den,
            quorum_fraction_num=s.quorum_fraction_num,
            state='SYNCHRONIZED',
        )
        effects = {
            'event': 'SYNC_COMPLETE',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    else:
        return StepResult(ok=False, error=f'unknown action: {cmd.tag}')


# === Hypothesis test scaffolding ===
# Uncomment and install hypothesis to use property-based testing

# from hypothesis import given, strategies as st
# from hypothesis.stateful import RuleBasedStateMachine, rule, initialize
#
# class ModelStateMachine(RuleBasedStateMachine):
#     def __init__(self):
#         super().__init__()
#         self.state = init_state()
#
#     @initialize()
#     def init(self):
#         self.state = init_state()
#         ok, _ = check_invariants(self.state)
#         assert ok, 'init violates invariants'
#
#     # @rule()
#     # def diverged_start_sync(self, ):
#     #     cmd = Command(tag='diverged_start_sync', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def peer_diverge_decrease_from_sync_keep(self, ):
#     #     cmd = Command(tag='peer_diverge_decrease_from_sync_keep', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def peer_diverge_decrease_from_sync_lose(self, ):
#     #     cmd = Command(tag='peer_diverge_decrease_from_sync_lose', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def peer_diverge_decrease_non_sync(self, ):
#     #     cmd = Command(tag='peer_diverge_decrease_non_sync', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def peer_matches_increase(self, ):
#     #     cmd = Command(tag='peer_matches_increase', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def peers_join_become_syncing(self, ):
#     #     cmd = Command(tag='peers_join_become_syncing', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def peers_join_steady(self, ):
#     #     cmd = Command(tag='peers_join_steady', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def peers_join_still_isolated(self, ):
#     #     cmd = Command(tag='peers_join_still_isolated', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def peers_leave_become_isolated(self, ):
#     #     cmd = Command(tag='peers_leave_become_isolated', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def peers_leave_matching(self, ):
#     #     cmd = Command(tag='peers_leave_matching', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def peers_leave_non_matching(self, ):
#     #     cmd = Command(tag='peers_leave_non_matching', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def state_diverge(self, ):
#     #     cmd = Command(tag='state_diverge', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def sync_complete_become_synchronized(self, ):
#     #     cmd = Command(tag='sync_complete_become_synchronized', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
# TestModel = ModelStateMachine.TestCase


def replay_trace(commands: list[tuple[str, dict[str, Any]]]) -> list[StepResult]:
    """Replay a trace of commands and return results."""
    results: list[StepResult] = []
    s = init_state()
    for tag, args in commands:
        cmd = Command(tag=tag, args=args)
        result = step(s, cmd)
        results.append(result)
        if result.ok and result.state is not None:
            s = result.state
        else:
            break
    return results


if __name__ == '__main__':
    # Quick sanity check
    s0 = init_state()
    ok, failed = check_invariants(s0)
    print(f'Initial state: {s0}')
    print(f'Invariants OK: {ok}')
    if not ok:
        print(f'  Failed: {failed}')
