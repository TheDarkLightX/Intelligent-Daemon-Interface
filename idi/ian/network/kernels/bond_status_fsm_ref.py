"""
Auto-generated Python reference model for: ian.bond_status
IR hash: sha256:03f7a2f7e474dbc926e207d115f24c6ce03bb39f88714905bd1e3fba23ab7f5a

Generated by ESSO (Evolutionary Spec Search Optimizer)

This file is standalone and has no ESSO dependencies.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Literal, Mapping


# Domain enums
STATUS_SYMBOLS = ('ACTIVE', 'LOCKED', 'SLASHED', 'WITHDRAWN')


@dataclass(frozen=True)
class State:
    """Model state."""
    amount: int
    min_bond: int
    status: str
    total_slashed: int


@dataclass(frozen=True)
class Command:
    """Command to execute."""
    tag: Literal('lock_bond', 'slash_below_min', 'slash_partial', 'topup', 'unlock_bond', 'withdraw_locked', 'withdraw_slashed')
    args: Mapping[str, Any]


@dataclass(frozen=True)
class StepResult:
    """Result of a step execution."""
    ok: bool
    state: State | None = None
    effects: Mapping[str, Any] | None = None
    error: str | None = None


def init_state() -> State:
    """Return the initial state."""
    return State(
        amount=0,
        min_bond=0,
        status='ACTIVE',
        total_slashed=0,
    )


def check_invariants(s: State) -> tuple[bool, str | None]:
    """Check all invariants. Returns (ok, first_failed_id)."""
    if not (isinstance(s.amount, int) and not isinstance(s.amount, bool) and 0 <= s.amount <= 1000000):
        return False, 'domain_amount'
    if not (isinstance(s.min_bond, int) and not isinstance(s.min_bond, bool) and 0 <= s.min_bond <= 100000):
        return False, 'domain_min_bond'
    if not (s.status in ('ACTIVE', 'LOCKED', 'SLASHED', 'WITHDRAWN')):
        return False, 'domain_status'
    if not (isinstance(s.total_slashed, int) and not isinstance(s.total_slashed, bool) and 0 <= s.total_slashed <= 1000000):
        return False, 'domain_total_slashed'
    if not ((('ACTIVE' != s.status) or ((s.amount - s.total_slashed) >= s.min_bond))):
        return False, 'active_has_valid_bond'
    if not ((s.total_slashed <= s.amount)):
        return False, 'slashed_not_exceeds_amount'
    if not ((('WITHDRAWN' != s.status) or (0 == (s.amount - s.total_slashed)))):
        return False, 'withdrawn_is_terminal'
    return True, None


def step(s: State, cmd: Command) -> StepResult:
    """Execute a step. Returns StepResult."""
    # Check pre-state invariants
    ok, failed = check_invariants(s)
    if not ok:
        return StepResult(ok=False, error=f'pre-invariant violated: {failed}')

    if cmd.tag == 'lock_bond':
        if not (('ACTIVE' == s.status)):
            return StepResult(ok=False, error='guard failed for lock_bond')
        # Compute updates (simultaneous)
        new_state = State(
            amount=s.amount,
            min_bond=s.min_bond,
            status='LOCKED',
            total_slashed=s.total_slashed,
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'slash_below_min':
        if 'slash_amount' not in cmd.args or not (isinstance(cmd.args['slash_amount'], int) and not isinstance(cmd.args['slash_amount'], bool) and 0 <= cmd.args['slash_amount'] <= 1000000):
            return StepResult(ok=False, error='invalid param slash_amount')
        if not (((((s.amount - s.total_slashed) - cmd.args['slash_amount']) < s.min_bond) and ((cmd.args['slash_amount'] + s.total_slashed) <= s.amount) and ('ACTIVE' == s.status))):
            return StepResult(ok=False, error='guard failed for slash_below_min')
        # Compute updates (simultaneous)
        new_state = State(
            amount=s.amount,
            min_bond=s.min_bond,
            status='SLASHED',
            total_slashed=(cmd.args['slash_amount'] + s.total_slashed),
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'slash_partial':
        if 'slash_amount' not in cmd.args or not (isinstance(cmd.args['slash_amount'], int) and not isinstance(cmd.args['slash_amount'], bool) and 0 <= cmd.args['slash_amount'] <= 1000000):
            return StepResult(ok=False, error='invalid param slash_amount')
        if not ((('WITHDRAWN' != s.status) and ((cmd.args['slash_amount'] + s.total_slashed) <= s.amount) and (((s.amount - s.total_slashed) - cmd.args['slash_amount']) >= s.min_bond))):
            return StepResult(ok=False, error='guard failed for slash_partial')
        # Compute updates (simultaneous)
        new_state = State(
            amount=s.amount,
            min_bond=s.min_bond,
            status=s.status,
            total_slashed=(cmd.args['slash_amount'] + s.total_slashed),
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'topup':
        if 'topup_amount' not in cmd.args or not (isinstance(cmd.args['topup_amount'], int) and not isinstance(cmd.args['topup_amount'], bool) and 0 <= cmd.args['topup_amount'] <= 1000000):
            return StepResult(ok=False, error='invalid param topup_amount')
        if not ((('WITHDRAWN' != s.status) and ((cmd.args['topup_amount'] + s.amount) <= 1000000))):
            return StepResult(ok=False, error='guard failed for topup')
        # Compute updates (simultaneous)
        new_state = State(
            amount=(cmd.args['topup_amount'] + s.amount),
            min_bond=s.min_bond,
            status=s.status,
            total_slashed=s.total_slashed,
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'unlock_bond':
        if not ((('LOCKED' == s.status) and ((s.amount - s.total_slashed) >= s.min_bond))):
            return StepResult(ok=False, error='guard failed for unlock_bond')
        # Compute updates (simultaneous)
        new_state = State(
            amount=s.amount,
            min_bond=s.min_bond,
            status='ACTIVE',
            total_slashed=s.total_slashed,
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'withdraw_locked':
        if not (('LOCKED' == s.status)):
            return StepResult(ok=False, error='guard failed for withdraw_locked')
        # Compute updates (simultaneous)
        new_state = State(
            amount=s.amount,
            min_bond=s.min_bond,
            status='WITHDRAWN',
            total_slashed=s.amount,
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'withdraw_slashed':
        if not (('SLASHED' == s.status)):
            return StepResult(ok=False, error='guard failed for withdraw_slashed')
        # Compute updates (simultaneous)
        new_state = State(
            amount=s.amount,
            min_bond=s.min_bond,
            status='WITHDRAWN',
            total_slashed=s.amount,
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    else:
        return StepResult(ok=False, error=f'unknown action: {cmd.tag}')


# === Hypothesis test scaffolding ===
# Uncomment and install hypothesis to use property-based testing

# from hypothesis import given, strategies as st
# from hypothesis.stateful import RuleBasedStateMachine, rule, initialize
#
# class ModelStateMachine(RuleBasedStateMachine):
#     def __init__(self):
#         super().__init__()
#         self.state = init_state()
#
#     @initialize()
#     def init(self):
#         self.state = init_state()
#         ok, _ = check_invariants(self.state)
#         assert ok, 'init violates invariants'
#
#     # @rule()
#     # def lock_bond(self, ):
#     #     cmd = Command(tag='lock_bond', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule(slash_amount=st.integers())
#     # def slash_below_min(self, slash_amount):
#     #     cmd = Command(tag='slash_below_min', args={'slash_amount': slash_amount})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule(slash_amount=st.integers())
#     # def slash_partial(self, slash_amount):
#     #     cmd = Command(tag='slash_partial', args={'slash_amount': slash_amount})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule(topup_amount=st.integers())
#     # def topup(self, topup_amount):
#     #     cmd = Command(tag='topup', args={'topup_amount': topup_amount})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def unlock_bond(self, ):
#     #     cmd = Command(tag='unlock_bond', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def withdraw_locked(self, ):
#     #     cmd = Command(tag='withdraw_locked', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def withdraw_slashed(self, ):
#     #     cmd = Command(tag='withdraw_slashed', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
# TestModel = ModelStateMachine.TestCase


def replay_trace(commands: list[tuple[str, dict[str, Any]]]) -> list[StepResult]:
    """Replay a trace of commands and return results."""
    results: list[StepResult] = []
    s = init_state()
    for tag, args in commands:
        cmd = Command(tag=tag, args=args)
        result = step(s, cmd)
        results.append(result)
        if result.ok and result.state is not None:
            s = result.state
        else:
            break
    return results


if __name__ == '__main__':
    # Quick sanity check
    s0 = init_state()
    ok, failed = check_invariants(s0)
    print(f'Initial state: {s0}')
    print(f'Invariants OK: {ok}')
    if not ok:
        print(f'  Failed: {failed}')
