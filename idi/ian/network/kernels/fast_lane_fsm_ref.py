"""
Auto-generated Python reference model for: fast_lane
IR hash: sha256:b62b51edcf9d285b0e789016de2f9fae6cf30138fb30dae7404d97d720887a3e

Generated by ESSO (Evolutionary Spec Search Optimizer)

This file is standalone and has no ESSO dependencies.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Literal, Mapping


# Domain enums
STATUS_SYMBOLS = ('IDLE', 'SAMPLING', 'VOTING', 'ACCEPTED', 'REJECTED', 'INDETERMINATE', 'TIMEOUT')


@dataclass(frozen=True)
class State:
    """Model state."""
    sample_size: int
    status: str
    threshold_pct: int
    votes_accept: int
    votes_received: int
    votes_reject: int


@dataclass(frozen=True)
class Command:
    """Command to execute."""
    tag: Literal('decide_accept', 'decide_indeterminate', 'decide_reject', 'reset', 'sampling_complete', 'start_sampling', 'timeout', 'vote_accept', 'vote_reject')
    args: Mapping[str, Any]


@dataclass(frozen=True)
class StepResult:
    """Result of a step execution."""
    ok: bool
    state: State | None = None
    effects: Mapping[str, Any] | None = None
    error: str | None = None


def init_state() -> State:
    """Return the initial state."""
    return State(
        sample_size=1,
        status='IDLE',
        threshold_pct=50,
        votes_accept=0,
        votes_received=0,
        votes_reject=0,
    )


def check_invariants(s: State) -> tuple[bool, str | None]:
    """Check all invariants. Returns (ok, first_failed_id)."""
    if not (isinstance(s.sample_size, int) and not isinstance(s.sample_size, bool) and 1 <= s.sample_size <= 20):
        return False, 'domain_sample_size'
    if not (s.status in ('IDLE', 'SAMPLING', 'VOTING', 'ACCEPTED', 'REJECTED', 'INDETERMINATE', 'TIMEOUT')):
        return False, 'domain_status'
    if not (isinstance(s.threshold_pct, int) and not isinstance(s.threshold_pct, bool) and 50 <= s.threshold_pct <= 100):
        return False, 'domain_threshold_pct'
    if not (isinstance(s.votes_accept, int) and not isinstance(s.votes_accept, bool) and 0 <= s.votes_accept <= 20):
        return False, 'domain_votes_accept'
    if not (isinstance(s.votes_received, int) and not isinstance(s.votes_received, bool) and 0 <= s.votes_received <= 20):
        return False, 'domain_votes_received'
    if not (isinstance(s.votes_reject, int) and not isinstance(s.votes_reject, bool) and 0 <= s.votes_reject <= 20):
        return False, 'domain_votes_reject'
    if not ((('ACCEPTED' != s.status) or ((100 * s.votes_accept) >= (s.threshold_pct * s.votes_received)))):
        return False, 'accepted_threshold'
    if not ((('IDLE' != s.status) or (0 == s.votes_received))):
        return False, 'idle_no_votes'
    if not ((s.votes_received <= s.sample_size)):
        return False, 'votes_bounded'
    if not (((s.votes_accept + s.votes_reject) == s.votes_received)):
        return False, 'votes_sum'
    return True, None


def step(s: State, cmd: Command) -> StepResult:
    """Execute a step. Returns StepResult."""
    # Check pre-state invariants
    ok, failed = check_invariants(s)
    if not ok:
        return StepResult(ok=False, error=f'pre-invariant violated: {failed}')

    if cmd.tag == 'decide_accept':
        if not ((('VOTING' == s.status) and ((100 * s.votes_accept) >= (s.threshold_pct * s.votes_received)) and (s.votes_received >= s.sample_size))):
            return StepResult(ok=False, error='guard failed for decide_accept')
        # Compute updates (simultaneous)
        new_state = State(
            sample_size=s.sample_size,
            status='ACCEPTED',
            threshold_pct=s.threshold_pct,
            votes_accept=s.votes_accept,
            votes_received=s.votes_received,
            votes_reject=s.votes_reject,
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'decide_indeterminate':
        if not (((s.votes_received < s.sample_size) and ('VOTING' == s.status))):
            return StepResult(ok=False, error='guard failed for decide_indeterminate')
        # Compute updates (simultaneous)
        new_state = State(
            sample_size=s.sample_size,
            status='INDETERMINATE',
            threshold_pct=s.threshold_pct,
            votes_accept=s.votes_accept,
            votes_received=s.votes_received,
            votes_reject=s.votes_reject,
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'decide_reject':
        if not ((((100 * s.votes_accept) < (s.threshold_pct * s.votes_received)) and ('VOTING' == s.status) and (s.votes_received >= s.sample_size))):
            return StepResult(ok=False, error='guard failed for decide_reject')
        # Compute updates (simultaneous)
        new_state = State(
            sample_size=s.sample_size,
            status='REJECTED',
            threshold_pct=s.threshold_pct,
            votes_accept=s.votes_accept,
            votes_received=s.votes_received,
            votes_reject=s.votes_reject,
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'reset':
        if not ((('IDLE' != s.status) and ('SAMPLING' != s.status) and ('VOTING' != s.status))):
            return StepResult(ok=False, error='guard failed for reset')
        # Compute updates (simultaneous)
        new_state = State(
            sample_size=s.sample_size,
            status='IDLE',
            threshold_pct=s.threshold_pct,
            votes_accept=0,
            votes_received=0,
            votes_reject=0,
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'sampling_complete':
        if not (('SAMPLING' == s.status)):
            return StepResult(ok=False, error='guard failed for sampling_complete')
        # Compute updates (simultaneous)
        new_state = State(
            sample_size=s.sample_size,
            status='VOTING',
            threshold_pct=s.threshold_pct,
            votes_accept=0,
            votes_received=0,
            votes_reject=0,
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'start_sampling':
        if not (('IDLE' == s.status)):
            return StepResult(ok=False, error='guard failed for start_sampling')
        # Compute updates (simultaneous)
        new_state = State(
            sample_size=s.sample_size,
            status='SAMPLING',
            threshold_pct=s.threshold_pct,
            votes_accept=0,
            votes_received=0,
            votes_reject=0,
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'timeout':
        if not (('VOTING' == s.status)):
            return StepResult(ok=False, error='guard failed for timeout')
        # Compute updates (simultaneous)
        new_state = State(
            sample_size=s.sample_size,
            status='TIMEOUT',
            threshold_pct=s.threshold_pct,
            votes_accept=s.votes_accept,
            votes_received=s.votes_received,
            votes_reject=s.votes_reject,
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'vote_accept':
        if not (((s.votes_received < 20) and (s.votes_received < s.sample_size) and ('VOTING' == s.status))):
            return StepResult(ok=False, error='guard failed for vote_accept')
        # Compute updates (simultaneous)
        new_state = State(
            sample_size=s.sample_size,
            status='VOTING',
            threshold_pct=s.threshold_pct,
            votes_accept=(1 + s.votes_accept),
            votes_received=(1 + s.votes_received),
            votes_reject=s.votes_reject,
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'vote_reject':
        if not (((s.votes_received < 20) and (s.votes_received < s.sample_size) and ('VOTING' == s.status))):
            return StepResult(ok=False, error='guard failed for vote_reject')
        # Compute updates (simultaneous)
        new_state = State(
            sample_size=s.sample_size,
            status='VOTING',
            threshold_pct=s.threshold_pct,
            votes_accept=s.votes_accept,
            votes_received=(1 + s.votes_received),
            votes_reject=(1 + s.votes_reject),
        )
        effects = {}
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    else:
        return StepResult(ok=False, error=f'unknown action: {cmd.tag}')


# === Hypothesis test scaffolding ===
# Uncomment and install hypothesis to use property-based testing

# from hypothesis import given, strategies as st
# from hypothesis.stateful import RuleBasedStateMachine, rule, initialize
#
# class ModelStateMachine(RuleBasedStateMachine):
#     def __init__(self):
#         super().__init__()
#         self.state = init_state()
#
#     @initialize()
#     def init(self):
#         self.state = init_state()
#         ok, _ = check_invariants(self.state)
#         assert ok, 'init violates invariants'
#
#     # @rule()
#     # def decide_accept(self, ):
#     #     cmd = Command(tag='decide_accept', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def decide_indeterminate(self, ):
#     #     cmd = Command(tag='decide_indeterminate', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def decide_reject(self, ):
#     #     cmd = Command(tag='decide_reject', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def reset(self, ):
#     #     cmd = Command(tag='reset', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def sampling_complete(self, ):
#     #     cmd = Command(tag='sampling_complete', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def start_sampling(self, ):
#     #     cmd = Command(tag='start_sampling', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def timeout(self, ):
#     #     cmd = Command(tag='timeout', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def vote_accept(self, ):
#     #     cmd = Command(tag='vote_accept', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule()
#     # def vote_reject(self, ):
#     #     cmd = Command(tag='vote_reject', args={})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
# TestModel = ModelStateMachine.TestCase


def replay_trace(commands: list[tuple[str, dict[str, Any]]]) -> list[StepResult]:
    """Replay a trace of commands and return results."""
    results: list[StepResult] = []
    s = init_state()
    for tag, args in commands:
        cmd = Command(tag=tag, args=args)
        result = step(s, cmd)
        results.append(result)
        if result.ok and result.state is not None:
            s = result.state
        else:
            break
    return results


if __name__ == '__main__':
    # Quick sanity check
    s0 = init_state()
    ok, failed = check_invariants(s0)
    print(f'Initial state: {s0}')
    print(f'Invariants OK: {ok}')
    if not ok:
        print(f'  Failed: {failed}')
