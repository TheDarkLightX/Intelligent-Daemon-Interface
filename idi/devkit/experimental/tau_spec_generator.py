"""Tau spec generation from AgentPatch parameters.

This module provides a minimal implementation of patch_to_tau_spec that
generates Tau temporal logic specifications encoding the key invariants
for QAgent patches.

The generated specs are compatible with Tau 0.7.0+ and encode:
- State size bounds (price_bins × inventory_bins ≤ max_cells)
- Discount factor constraints (discount ≥ min_discount)
- Learning rate bounds (for conservative profiles)
- Basic safety properties (no unbounded growth)

This is a "stretch goal" implementation per the production readiness
checklist. The specs can be verified using the tau-lang toolchain.
"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, List, Optional

from idi.devkit.experimental.agent_patch import AgentPatch
from idi.devkit.experimental.sape_q_patch import QAgentPatch


# ---------------------------------------------------------------------------
# Tau Spec Constants
# ---------------------------------------------------------------------------

TAU_VERSION = "0.7.0"
DEFAULT_MAX_STATE_CELLS = 256
DEFAULT_MIN_DISCOUNT = 0.9
DEFAULT_MAX_LEARNING_RATE = 0.5
DEFAULT_MAX_EXPLORATION = 1.0


@dataclass
class TauSpecConfig:
    """Configuration for Tau spec generation."""

    max_state_cells: int = DEFAULT_MAX_STATE_CELLS
    min_discount: float = DEFAULT_MIN_DISCOUNT
    max_learning_rate: float = DEFAULT_MAX_LEARNING_RATE
    max_exploration: float = DEFAULT_MAX_EXPLORATION
    include_zk_constraints: bool = False
    output_dir: Optional[Path] = None


@dataclass
class TauSpecResult:
    """Result of Tau spec generation."""

    spec_text: str
    invariants: List[str]
    warnings: List[str]
    patch_id: str


# ---------------------------------------------------------------------------
# Tau Spec Templates
# ---------------------------------------------------------------------------

TAU_SPEC_HEADER = """# Auto-generated Tau spec for QAgent patch: {patch_id}
# Generated by idi.devkit.experimental.tau_spec_generator
# Tau version: {tau_version}
#
# Invariants encoded:
{invariants_comment}
#
# This spec encodes formal constraints from the AgentPatch configuration.
# Violations of these constraints can be detected at design time.

"""

TAU_SPEC_PARAMS = """# --------------------------------------------------------------------------
# Patch Parameters (encoded as constants)
# --------------------------------------------------------------------------

# State discretization
param_price_bins := {price_bins}.
param_inventory_bins := {inventory_bins}.
param_state_cells := {state_cells}.

# Learning dynamics
param_discount := {discount}.
param_learning_rate := {learning_rate}.
param_epsilon_start := {epsilon_start}.
param_epsilon_end := {epsilon_end}.

# Bounds
bound_max_state_cells := {max_state_cells}.
bound_min_discount := {min_discount}.
bound_max_learning_rate := {max_learning_rate}.
bound_max_exploration := {max_exploration}.

"""

TAU_SPEC_INVARIANTS = """# --------------------------------------------------------------------------
# Formal Invariants
# --------------------------------------------------------------------------

# I1: State size bound
# The total state space must not exceed max_state_cells to prevent
# state explosion and ensure tractable Q-table representation.
invariant_state_size_bound :=
    (param_state_cells <= bound_max_state_cells).

# I2: Discount factor bound
# Discount must be at least min_discount to ensure long-term reward
# consideration and stable learning dynamics.
invariant_discount_bound :=
    (param_discount >= bound_min_discount).

# I3: Learning rate bound
# Learning rate must not exceed max to prevent unstable updates.
invariant_learning_rate_bound :=
    (param_learning_rate <= bound_max_learning_rate).

# I4: Exploration bound
# Initial exploration must be bounded to prevent purely random behavior.
invariant_exploration_bound :=
    (param_epsilon_start <= bound_max_exploration).

# I5: Exploration decay validity
# Final exploration must be less than or equal to initial.
invariant_exploration_decay_valid :=
    (param_epsilon_end <= param_epsilon_start).

"""

TAU_SPEC_SAFETY = """# --------------------------------------------------------------------------
# Safety Properties (temporal)
# --------------------------------------------------------------------------

# S1: No unbounded state growth
# The state representation is fixed at initialization and cannot grow.
# This is implicitly enforced by the discrete Q-table structure.

# S2: Bounded action space
# The agent can only take actions in {BUY, SELL, HOLD}.
# This is enforced by the environment interface.

# S3: Learning rate stability
# The learning rate does not change during training.
# (Future: could add adaptive rate constraints here)

"""

TAU_SPEC_COMBINED = """# --------------------------------------------------------------------------
# Combined Specification
# --------------------------------------------------------------------------

# The patch is valid if and only if all invariants hold.
patch_valid :=
    invariant_state_size_bound &&
    invariant_discount_bound &&
    invariant_learning_rate_bound &&
    invariant_exploration_bound &&
    invariant_exploration_decay_valid.

"""


# ---------------------------------------------------------------------------
# Spec Generation Functions
# ---------------------------------------------------------------------------

def qagent_patch_to_tau_spec(
    patch: QAgentPatch,
    config: TauSpecConfig | None = None,
) -> TauSpecResult:
    """Generate a Tau spec from a QAgentPatch.

    Args:
        patch: The QAgentPatch to generate a spec for.
        config: Optional configuration for spec generation.

    Returns:
        TauSpecResult containing the generated spec and metadata.
    """
    if config is None:
        config = TauSpecConfig()

    warnings: List[str] = []
    invariants: List[str] = []

    # Calculate derived values
    state_cells = patch.num_price_bins * patch.num_inventory_bins

    # Check invariants and collect warnings
    if state_cells > config.max_state_cells:
        warnings.append(
            f"State cells ({state_cells}) exceeds max ({config.max_state_cells})"
        )
    invariants.append(f"I1: state_cells ≤ {config.max_state_cells}")

    if patch.discount_factor < config.min_discount:
        warnings.append(
            f"Discount ({patch.discount_factor}) below min ({config.min_discount})"
        )
    invariants.append(f"I2: discount ≥ {config.min_discount}")

    if patch.learning_rate > config.max_learning_rate:
        warnings.append(
            f"Learning rate ({patch.learning_rate}) exceeds max ({config.max_learning_rate})"
        )
    invariants.append(f"I3: learning_rate ≤ {config.max_learning_rate}")

    if patch.epsilon_start > config.max_exploration:
        warnings.append(
            f"Exploration ({patch.epsilon_start}) exceeds max ({config.max_exploration})"
        )
    invariants.append(f"I4: exploration ≤ {config.max_exploration}")

    if patch.epsilon_end > patch.epsilon_start:
        warnings.append(
            f"Epsilon end ({patch.epsilon_end}) > epsilon start ({patch.epsilon_start})"
        )
    invariants.append("I5: epsilon_end ≤ epsilon_start")

    # Build invariants comment
    invariants_comment = "\n".join(f"#   - {inv}" for inv in invariants)

    # Generate spec sections
    header = TAU_SPEC_HEADER.format(
        patch_id=patch.identifier,
        tau_version=TAU_VERSION,
        invariants_comment=invariants_comment,
    )

    params = TAU_SPEC_PARAMS.format(
        price_bins=patch.num_price_bins,
        inventory_bins=patch.num_inventory_bins,
        state_cells=state_cells,
        discount=patch.discount_factor,
        learning_rate=patch.learning_rate,
        epsilon_start=patch.epsilon_start,
        epsilon_end=patch.epsilon_end,
        max_state_cells=config.max_state_cells,
        min_discount=config.min_discount,
        max_learning_rate=config.max_learning_rate,
        max_exploration=config.max_exploration,
    )

    # Combine all sections
    spec_text = header + params + TAU_SPEC_INVARIANTS + TAU_SPEC_SAFETY + TAU_SPEC_COMBINED

    return TauSpecResult(
        spec_text=spec_text,
        invariants=invariants,
        warnings=warnings,
        patch_id=patch.identifier,
    )


def agent_patch_to_tau_spec(
    patch: AgentPatch,
    config: TauSpecConfig | None = None,
) -> TauSpecResult:
    """Generate a Tau spec from a generic AgentPatch.

    For QAgent patches (agent_type == "qtable"), extracts parameters
    from the payload and generates a QAgent-specific spec.

    Args:
        patch: The AgentPatch to generate a spec for.
        config: Optional configuration for spec generation.

    Returns:
        TauSpecResult containing the generated spec and metadata.

    Raises:
        ValueError: If the agent type is not supported.
    """
    if patch.agent_type != "qtable":
        raise ValueError(f"Tau spec generation not supported for agent_type: {patch.agent_type}")

    # Extract QAgent parameters from payload
    payload = patch.payload

    # Create a QAgentPatch from the payload
    from idi.devkit.experimental.sape_q_patch import QPatchMeta

    meta = QPatchMeta(
        name=patch.meta.name,
        description=patch.meta.description,
        version=patch.meta.version,
        tags=patch.meta.tags,
    )

    qpatch = QAgentPatch(
        identifier=patch.meta.id,
        num_price_bins=int(payload.get("num_price_bins", 10)),
        num_inventory_bins=int(payload.get("num_inventory_bins", 10)),
        learning_rate=float(payload.get("learning_rate", 0.1)),
        discount_factor=float(payload.get("discount_factor", 0.99)),
        epsilon_start=float(payload.get("epsilon_start", 0.5)),
        epsilon_end=float(payload.get("epsilon_end", 0.1)),
        epsilon_decay_steps=int(payload.get("epsilon_decay_steps", 1000)),
        meta=meta,
    )

    return qagent_patch_to_tau_spec(qpatch, config)


def save_tau_spec(result: TauSpecResult, output_path: Path) -> None:
    """Save a generated Tau spec to a file.

    Args:
        result: The TauSpecResult to save.
        output_path: Path to write the spec file.
    """
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(result.spec_text)


def validate_patch_against_spec(
    patch: QAgentPatch,
    config: TauSpecConfig | None = None,
) -> tuple[bool, List[str]]:
    """Validate a patch against the formal spec constraints.

    This is a quick check that doesn't require the full Tau toolchain.
    It verifies that the patch parameters satisfy all invariants.

    Args:
        patch: The patch to validate.
        config: Optional configuration with constraint bounds.

    Returns:
        Tuple of (is_valid, list_of_violations).
    """
    if config is None:
        config = TauSpecConfig()

    violations: List[str] = []

    state_cells = patch.num_price_bins * patch.num_inventory_bins
    if state_cells > config.max_state_cells:
        violations.append(
            f"I1 violated: state_cells ({state_cells}) > max ({config.max_state_cells})"
        )

    if patch.discount_factor < config.min_discount:
        violations.append(
            f"I2 violated: discount ({patch.discount_factor}) < min ({config.min_discount})"
        )

    if patch.learning_rate > config.max_learning_rate:
        violations.append(
            f"I3 violated: learning_rate ({patch.learning_rate}) > max ({config.max_learning_rate})"
        )

    if patch.epsilon_start > config.max_exploration:
        violations.append(
            f"I4 violated: exploration ({patch.epsilon_start}) > max ({config.max_exploration})"
        )

    if patch.epsilon_end > patch.epsilon_start:
        violations.append(
            f"I5 violated: epsilon_end ({patch.epsilon_end}) > epsilon_start ({patch.epsilon_start})"
        )

    return len(violations) == 0, violations
