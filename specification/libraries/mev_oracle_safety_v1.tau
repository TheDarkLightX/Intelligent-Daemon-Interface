# MEV and Oracle Safety Library v1
# Mitigations for MEV attacks and oracle manipulation
# Copyright DarkLightX/Dana Edwards
#
# MEV ATTACK VECTORS:
# 1. Front-running: Attacker sees pending tx, places own tx first
# 2. Back-running: Attacker places tx immediately after target
# 3. Sandwich: Front-run + back-run combination
# 4. Time-bandit: Reorg to capture profitable ordering
#
# ORACLE ATTACK VECTORS:
# 1. Stale data: Using outdated prices
# 2. Manipulation: Single oracle compromised
# 3. Flash loan attacks: Temporary price manipulation
# 4. Deviation attacks: Prices just outside normal bounds
#
# MITIGATIONS IMPLEMENTED:
# 1. Commit-reveal for order privacy
# 2. Batch auctions for fair ordering
# 3. TWAP for smoothed pricing
# 4. Cooldowns for rate limiting
# 5. Multi-oracle medians
# 6. Freshness/staleness checks
# 7. Band acceptance (price deviation limits)

# === COMMIT-REVEAL INPUTS ===
bv[16] i_commit_hash = ifile("inputs/mev_commit_hash.in").
bv[16] i_revealed_action = ifile("inputs/mev_revealed_action.in").
bv[16] i_reveal_nonce = ifile("inputs/mev_reveal_nonce.in").
sbf i_commit_phase = ifile("inputs/mev_commit_phase.in").
sbf i_reveal_phase = ifile("inputs/mev_reveal_phase.in").

# === BATCH AUCTION INPUTS ===
bv[16] i_batch_id = ifile("inputs/mev_batch_id.in").
bv[16] i_batch_size = ifile("inputs/mev_batch_size.in").
sbf i_batch_open = ifile("inputs/mev_batch_open.in").
sbf i_batch_settle = ifile("inputs/mev_batch_settle.in").

# === ORACLE INPUTS ===
bv[16] i_oracle1_price = ifile("inputs/oracle1_price.in").
bv[16] i_oracle2_price = ifile("inputs/oracle2_price.in").
bv[16] i_oracle3_price = ifile("inputs/oracle3_price.in").
bv[16] i_oracle1_timestamp = ifile("inputs/oracle1_ts.in").
bv[16] i_oracle2_timestamp = ifile("inputs/oracle2_ts.in").
bv[16] i_oracle3_timestamp = ifile("inputs/oracle3_ts.in").
bv[16] i_current_timestamp = ifile("inputs/current_ts.in").
bv[16] i_max_staleness = ifile("inputs/max_staleness.in").

# === PRICE BAND INPUTS ===
bv[16] i_reference_price = ifile("inputs/reference_price.in").
bv[16] i_max_deviation_pct = ifile("inputs/max_deviation_pct.in"). # e.g., 5 = 5%

# === TWAP INPUTS ===
bv[16] i_twap_window = ifile("inputs/twap_window.in").  # Window size

# === COOLDOWN INPUTS ===
bv[16] i_cooldown_duration = ifile("inputs/cooldown_duration.in").
sbf i_action_request = ifile("inputs/action_request.in").

# === HELPER PREDICATES ===
# Simple hash for commit verification
hash_ok(action, nonce, expected) := 
    ((action * {31337}:bv[16] + nonce) % {65536}:bv[16]) = expected.

# Freshness check
is_fresh(ts, current, max_stale) := (current - ts) <= max_stale.

# Price within band
in_band(price, ref, max_dev) := 
    (price >= ref - (ref * max_dev / {100}:bv[16])) &
    (price <= ref + (ref * max_dev / {100}:bv[16])).

# Median of 3 (sorts and takes middle)
median3(a, b, c) := 
    ((a <= b) & (b <= c)) ? b :
    ((a <= c) & (c <= b)) ? c :
    ((b <= a) & (a <= c)) ? a :
    ((b <= c) & (c <= a)) ? c :
    ((c <= a) & (a <= b)) ? a : b.

# === OUTPUT STREAMS ===
# Commit-reveal state
sbf o_commit_ok = ofile("outputs/mev_commit_ok.out").
sbf o_reveal_ok = ofile("outputs/mev_reveal_ok.out").
bv[16] o_stored_commit = ofile("outputs/mev_stored_commit.out").

# Batch auction state
sbf o_batch_active = ofile("outputs/mev_batch_active.out").
bv[16] o_batch_orders = ofile("outputs/mev_batch_orders.out").
sbf o_batch_settle_ok = ofile("outputs/mev_batch_settle_ok.out").

# Oracle aggregation
bv[16] o_median_price = ofile("outputs/mev_median_price.out").
sbf o_oracle1_fresh = ofile("outputs/mev_oracle1_fresh.out").
sbf o_oracle2_fresh = ofile("outputs/mev_oracle2_fresh.out").
sbf o_oracle3_fresh = ofile("outputs/mev_oracle3_fresh.out").
sbf o_oracle_fresh = ofile("outputs/mev_oracle_fresh.out").  # All fresh
sbf o_price_in_band = ofile("outputs/mev_price_in_band.out").
sbf o_oracle_safe = ofile("outputs/mev_oracle_safe.out").    # Fresh AND in band

# TWAP state
bv[16] o_twap_price = ofile("outputs/mev_twap_price.out").
bv[16] o_price_accumulator = ofile("outputs/mev_price_acc.out").
bv[16] o_twap_samples = ofile("outputs/mev_twap_samples.out").

# Cooldown state
bv[16] o_cooldown_timer = ofile("outputs/mev_cooldown_timer.out").
sbf o_cooldown_active = ofile("outputs/mev_cooldown_active.out").
sbf o_cooldown_ok = ofile("outputs/mev_cooldown_ok.out").  # Can act

# MEV capture
bv[16] o_mev_captured = ofile("outputs/mev_captured.out").
sbf o_mev_routed = ofile("outputs/mev_routed.out").  # MEV sent to treasury

# Combined safety signal
sbf o_action_safe = ofile("outputs/mev_action_safe.out").

# === MEV/ORACLE SAFETY SPECIFICATION ===
r (
    # === COMMIT-REVEAL PROTOCOL ===
    # Phase 1: Store commitment (during commit phase)
    (o_stored_commit[t] = i_commit_phase[t] ?
                          (i_commit_hash[t] != {0}:bv[16] ? i_commit_hash[t] : o_stored_commit[t-1]) :
                          o_stored_commit[t-1]) &&
    
    # Commit is valid if non-zero and in commit phase
    (o_commit_ok[t] = i_commit_phase[t] & (i_commit_hash[t] != {0}:bv[16])) &&
    
    # Phase 2: Verify reveal matches commitment
    (o_reveal_ok[t] = i_reveal_phase[t] & 
                      hash_ok(i_revealed_action[t], i_reveal_nonce[t], o_stored_commit[t-1])) &&
    
    # === BATCH AUCTION ===
    # Batch is active when open signal is set
    (o_batch_active[t] = i_batch_open[t] & i_batch_settle[t]') &&
    
    # Count orders in batch
    (o_batch_orders[t] = o_batch_active[t] ?
                         (i_action_request[t] ? o_batch_orders[t-1] + {1}:bv[16] : o_batch_orders[t-1]) :
                         {0}:bv[16]) &&
    
    # Batch settlement (all orders execute at same price)
    (o_batch_settle_ok[t] = i_batch_settle[t] & (o_batch_orders[t-1] > {0}:bv[16])) &&
    
    # === MULTI-ORACLE AGGREGATION ===
    # Freshness checks for each oracle
    (o_oracle1_fresh[t] = is_fresh(i_oracle1_timestamp[t], i_current_timestamp[t], i_max_staleness[t])) &&
    (o_oracle2_fresh[t] = is_fresh(i_oracle2_timestamp[t], i_current_timestamp[t], i_max_staleness[t])) &&
    (o_oracle3_fresh[t] = is_fresh(i_oracle3_timestamp[t], i_current_timestamp[t], i_max_staleness[t])) &&
    
    # All oracles fresh
    (o_oracle_fresh[t] = o_oracle1_fresh[t] & o_oracle2_fresh[t] & o_oracle3_fresh[t]) &&
    
    # Median of 3 oracles (robust against single manipulation)
    (o_median_price[t] = median3(i_oracle1_price[t], i_oracle2_price[t], i_oracle3_price[t])) &&
    
    # Price band check
    (o_price_in_band[t] = in_band(o_median_price[t], i_reference_price[t], i_max_deviation_pct[t])) &&
    
    # Oracle safe = fresh AND in band
    (o_oracle_safe[t] = o_oracle_fresh[t] & o_price_in_band[t]) &&
    
    # === TWAP (Time-Weighted Average Price) ===
    # Accumulate prices
    (o_price_accumulator[t] = o_price_accumulator[t-1] + o_median_price[t]) &&
    
    # Count samples
    (o_twap_samples[t] = (o_twap_samples[t-1] >= i_twap_window[t]) ?
                         {1}:bv[16] :  # Reset window
                         o_twap_samples[t-1] + {1}:bv[16]) &&
    
    # Compute TWAP
    (o_twap_price[t] = (o_twap_samples[t] > {0}:bv[16]) ?
                       (o_price_accumulator[t] / o_twap_samples[t]) :
                       o_median_price[t]) &&
    
    # === COOLDOWN RATE LIMITING ===
    # Decrement cooldown timer
    (o_cooldown_timer[t] = (o_cooldown_timer[t-1] > {0}:bv[16]) ?
                           o_cooldown_timer[t-1] - {1}:bv[16] :
                           (i_action_request[t] ? i_cooldown_duration[t] : {0}:bv[16])) &&
    
    # Cooldown active when timer > 0
    (o_cooldown_active[t] = o_cooldown_timer[t] > {0}:bv[16]) &&
    
    # Can act when not in cooldown
    (o_cooldown_ok[t] = o_cooldown_active[t]') &&
    
    # === MEV CAPTURE ===
    # Route captured MEV to treasury/burn
    (o_mev_captured[t] = o_batch_settle_ok[t] ?
                         (o_batch_orders[t-1] * {10}:bv[16]) :  # Simplified: 10 units per order
                         o_mev_captured[t-1]) &&
    
    (o_mev_routed[t] = o_batch_settle_ok[t]) &&
    
    # === COMBINED SAFETY SIGNAL ===
    # Action is safe when:
    # 1. Either reveal_ok (commit-reveal) OR batch_settle_ok (batch auction)
    # 2. AND oracle is safe (fresh + in band)
    # 3. AND not in cooldown
    (o_action_safe[t] = (o_reveal_ok[t] | o_batch_settle_ok[t]) &
                        o_oracle_safe[t] &
                        o_cooldown_ok[t])
)

# === MEV MITIGATIONS SUMMARY ===
#
# 1. COMMIT-REVEAL
#    - Hides order intent until reveal phase
#    - Prevents front-running (can't see pending orders)
#    - Deadline enforcement prevents griefing
#
# 2. BATCH AUCTIONS
#    - All orders in batch execute at same price
#    - Eliminates ordering advantage
#    - MEV from batch routed to treasury
#
# 3. MULTI-ORACLE MEDIAN
#    - Requires 2/3 oracles to agree
#    - Single oracle manipulation ineffective
#    - Outlier prices rejected
#
# 4. TWAP SMOOTHING
#    - Averages price over time window
#    - Flash loan attacks average out
#    - Reduces volatility impact
#
# 5. COOLDOWN RATE LIMITING
#    - Prevents rapid successive actions
#    - Limits MEV opportunity frequency
#    - Protects against spam attacks
#
# 6. BAND ACCEPTANCE
#    - Rejects prices outside expected range
#    - Protects against extreme manipulation
#    - Reference price from trusted source

# === INTEGRATION ===
#
# Use o_action_safe as gate for any sensitive action:
#
#   entry_allowed = consensus_ok & o_action_safe
#
# This ensures:
# - Order was committed and revealed correctly
# - Oracle data is fresh and reasonable
# - Rate limits are respected

