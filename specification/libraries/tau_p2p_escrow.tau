# Tau-P2P: ZKP2P-Style Verified Escrow Protocol
# Implements the orchestration layer for trustless P2P exchanges
# Copyright DarkLightX/Dana Edwards
#
# ARCHITECTURE:
# ┌─────────────────────────────────────────────────────────────┐
# │                    TAU SPECIFICATION                        │
# │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │
# │  │   ESCROW    │  │    STATE    │  │     INVARIANTS      │ │
# │  │  PREDICATES │  │   MACHINE   │  │  (formally proven)  │ │
# │  └─────────────┘  └─────────────┘  └─────────────────────┘ │
# │         ▲                ▲                    ▲            │
# └─────────┼────────────────┼────────────────────┼────────────┘
#           │                │                    │
#     ┌─────┴────┐     ┌─────┴────┐         ┌────┴─────┐
#     │  DAEMON  │     │  ORACLE  │         │EXTERNAL  │
#     │(custody) │     │(prices)  │         │ZKP VERIFY│
#     └──────────┘     └──────────┘         └──────────┘
#                                                 │
#                                    ┌────────────┴───────────┐
#                                    │  zkTLS / MPC-TLS /     │
#                                    │  zkEmail / TEE         │
#                                    └────────────────────────┘
#
# WHY TAU FOR THIS:
# 1. Escrow predicates are PROVABLY CORRECT - funds release IFF conditions met
# 2. State machine FORMALLY VERIFIED - no stuck states, no double-release
# 3. Temporal invariants expressible - "eventually settled OR refunded"
# 4. Decidable = always terminates = safe for financial logic
#
# LIMITATIONS:
# - Cannot do ZKP cryptography directly (EC, hashing)
# - Accepts ZKP verification result as BOOLEAN INPUT from verifier
# - 32-bit arithmetic max (sufficient for state/amounts)

# ============================================================================
# STATE ENCODING (3 bits = 8 states)
# ============================================================================
# 000 = IDLE         - No active order
# 001 = OPEN         - Seller posted intent, awaiting buyer match
# 010 = MATCHED      - Buyer matched, escrow locked
# 011 = PROVING      - Buyer submitted proof, awaiting verification
# 100 = VERIFIED     - ZKP verified, ready for release
# 101 = SETTLED      - Escrow released to buyer
# 110 = DISPUTED     - Dispute raised, awaiting resolution
# 111 = CANCELLED    - Order cancelled, refund to seller

# ============================================================================
# INPUT STREAMS
# ============================================================================

# === ORDER PARAMETERS ===
bv[32] i_order_id = ifile("inputs/p2p_order_id.in").
bv[32] i_sell_amount = ifile("inputs/p2p_sell_amount.in").     # Crypto amount
bv[32] i_buy_amount = ifile("inputs/p2p_buy_amount.in").       # Fiat amount
bv[16] i_min_rate = ifile("inputs/p2p_min_rate.in").           # Min exchange rate
bv[16] i_max_rate = ifile("inputs/p2p_max_rate.in").           # Max exchange rate

# === PARTICIPANT IDENTIFIERS ===
bv[16] i_seller_id = ifile("inputs/p2p_seller_id.in").
bv[16] i_buyer_id = ifile("inputs/p2p_buyer_id.in").

# === ACTION SIGNALS ===
sbf i_create_order = ifile("inputs/p2p_create_order.in").      # Seller creates
sbf i_match_order = ifile("inputs/p2p_match_order.in").        # Buyer matches
sbf i_submit_proof = ifile("inputs/p2p_submit_proof.in").      # Buyer submits ZKP
sbf i_cancel_order = ifile("inputs/p2p_cancel_order.in").      # Cancel request
sbf i_dispute = ifile("inputs/p2p_dispute.in").                # Raise dispute

# === ZKP VERIFICATION INPUT (from external verifier) ===
sbf i_zkp_valid = ifile("inputs/p2p_zkp_valid.in").            # ZKP verified TRUE
sbf i_zkp_invalid = ifile("inputs/p2p_zkp_invalid.in").        # ZKP verified FALSE

# === PROOF METADATA (from ZKP) ===
bv[16] i_proof_payment_id = ifile("inputs/p2p_proof_payment_id.in").
bv[32] i_proof_amount = ifile("inputs/p2p_proof_amount.in").
bv[16] i_proof_timestamp = ifile("inputs/p2p_proof_timestamp.in").
bv[16] i_proof_seller_id = ifile("inputs/p2p_proof_seller_id.in").

# === TIMING ===
bv[16] i_current_time = ifile("inputs/p2p_current_time.in").
bv[16] i_lock_duration = ifile("inputs/p2p_lock_duration.in"). # Time for proof
bv[16] i_dispute_duration = ifile("inputs/p2p_dispute_duration.in").

# === DISPUTE RESOLUTION ===
sbf i_dispute_resolved_buyer = ifile("inputs/p2p_resolve_buyer.in").
sbf i_dispute_resolved_seller = ifile("inputs/p2p_resolve_seller.in").

# === FEE PARAMETERS ===
bv[16] i_protocol_fee_bps = ifile("inputs/p2p_fee_bps.in").    # Basis points (100 = 1%)

# ============================================================================
# OUTPUT STREAMS
# ============================================================================

# === STATE ===
sbf o_state_b0 = ofile("outputs/p2p_state_b0.out").
sbf o_state_b1 = ofile("outputs/p2p_state_b1.out").
sbf o_state_b2 = ofile("outputs/p2p_state_b2.out").

# === ORDER DATA ===
bv[32] o_escrowed_amount = ofile("outputs/p2p_escrowed.out").
bv[16] o_escrow_lock_time = ofile("outputs/p2p_lock_time.out").
bv[16] o_matched_buyer = ofile("outputs/p2p_matched_buyer.out").
bv[16] o_matched_seller = ofile("outputs/p2p_matched_seller.out").

# === ACTIONS ===
sbf o_lock_escrow = ofile("outputs/p2p_lock_escrow.out").      # Lock funds
sbf o_release_buyer = ofile("outputs/p2p_release_buyer.out").  # Release to buyer
sbf o_refund_seller = ofile("outputs/p2p_refund_seller.out").  # Refund to seller
sbf o_slash_deposit = ofile("outputs/p2p_slash.out").          # Slash bad actor

# === FEE OUTPUTS ===
bv[16] o_protocol_fee = ofile("outputs/p2p_protocol_fee.out").
bv[16] o_burn_amount = ofile("outputs/p2p_burn_amount.out").

# === INVARIANT MONITORS ===
sbf o_funds_safe = ofile("outputs/p2p_funds_safe.out").        # Escrow integrity
sbf o_no_double_release = ofile("outputs/p2p_no_double.out").  # Single release
sbf o_timeout_protected = ofile("outputs/p2p_timeout_ok.out"). # Liveness
sbf o_state_valid = ofile("outputs/p2p_state_valid.out").      # Valid state

# ============================================================================
# HELPER PREDICATES
# ============================================================================

# State encoding
is_idle(b2, b1, b0) := b2' & b1' & b0'.
is_open(b2, b1, b0) := b2' & b1' & b0.
is_matched(b2, b1, b0) := b2' & b1 & b0'.
is_proving(b2, b1, b0) := b2' & b1 & b0.
is_verified(b2, b1, b0) := b2 & b1' & b0'.
is_settled(b2, b1, b0) := b2 & b1' & b0.
is_disputed(b2, b1, b0) := b2 & b1 & b0'.
is_cancelled(b2, b1, b0) := b2 & b1 & b0.

# Active escrow states (funds locked)
escrow_active(b2, b1, b0) := is_matched(b2, b1, b0) | is_proving(b2, b1, b0) |
                             is_verified(b2, b1, b0) | is_disputed(b2, b1, b0).

# Terminal states
is_terminal(b2, b1, b0) := is_settled(b2, b1, b0) | is_cancelled(b2, b1, b0).

# Proof validation (metadata matches order)
proof_valid(proof_seller, seller, proof_amount, amount) :=
    (proof_seller = seller) & (proof_amount >= amount).

# Timeout check
timed_out(lock_time, current, duration) := (current - lock_time) > duration.

# Fee calculation (amount * fee_bps / 10000)
calc_fee(amount, fee_bps) := amount * fee_bps / {10000}:bv[32].

# ============================================================================
# TAU-P2P SPECIFICATION
# ============================================================================
r (
    # ==== STATE MACHINE ====
    
    # IDLE -> OPEN (seller creates order)
    # IDLE persists until valid create signal
    (o_state_b0[t] =
        (is_idle(o_state_b2[t-1], o_state_b1[t-1], o_state_b0[t-1]) & i_create_order[t]) |
        (is_open(o_state_b2[t-1], o_state_b1[t-1], o_state_b0[t-1]) & i_match_order[t]') |
        (is_matched(o_state_b2[t-1], o_state_b1[t-1], o_state_b0[t-1]) & i_submit_proof[t]') |
        (is_proving(o_state_b2[t-1], o_state_b1[t-1], o_state_b0[t-1]) & i_zkp_valid[t]) |
        (is_disputed(o_state_b2[t-1], o_state_b1[t-1], o_state_b0[t-1]) & i_dispute_resolved_buyer[t]') |
        is_terminal(o_state_b2[t-1], o_state_b1[t-1], o_state_b0[t-1])) &&
    
    (o_state_b1[t] =
        (is_open(o_state_b2[t-1], o_state_b1[t-1], o_state_b0[t-1]) & i_match_order[t]) |
        (is_matched(o_state_b2[t-1], o_state_b1[t-1], o_state_b0[t-1]) & i_submit_proof[t]) |
        (is_proving(o_state_b2[t-1], o_state_b1[t-1], o_state_b0[t-1]) & i_dispute[t]) |
        (is_disputed(o_state_b2[t-1], o_state_b1[t-1], o_state_b0[t-1])) |
        (is_idle(o_state_b2[t-1], o_state_b1[t-1], o_state_b0[t-1]) & i_cancel_order[t]) |
        is_cancelled(o_state_b2[t-1], o_state_b1[t-1], o_state_b0[t-1])) &&
    
    (o_state_b2[t] =
        (is_proving(o_state_b2[t-1], o_state_b1[t-1], o_state_b0[t-1]) & 
         (i_zkp_valid[t] | timed_out(o_escrow_lock_time[t-1], i_current_time[t], i_lock_duration[t]))) |
        is_verified(o_state_b2[t-1], o_state_b1[t-1], o_state_b0[t-1]) |
        is_settled(o_state_b2[t-1], o_state_b1[t-1], o_state_b0[t-1]) |
        (is_disputed(o_state_b2[t-1], o_state_b1[t-1], o_state_b0[t-1]) & 
         (i_dispute_resolved_buyer[t] | i_dispute_resolved_seller[t])) |
        (is_open(o_state_b2[t-1], o_state_b1[t-1], o_state_b0[t-1]) & i_cancel_order[t]) |
        is_cancelled(o_state_b2[t-1], o_state_b1[t-1], o_state_b0[t-1])) &&
    
    # ==== ESCROW MANAGEMENT ====
    
    # Lock escrow when matched
    (o_lock_escrow[t] = is_open(o_state_b2[t-1], o_state_b1[t-1], o_state_b0[t-1]) & 
                        i_match_order[t]) &&
    
    # Track escrowed amount
    (o_escrowed_amount[t] = o_lock_escrow[t] ? i_sell_amount[t] :
                            (o_release_buyer[t] | o_refund_seller[t]) ? {0}:bv[32] :
                            o_escrowed_amount[t-1]) &&
    
    # Lock time for timeout
    (o_escrow_lock_time[t] = o_lock_escrow[t] ? i_current_time[t] :
                              o_escrow_lock_time[t-1]) &&
    
    # Track participants
    (o_matched_buyer[t] = o_lock_escrow[t] ? i_buyer_id[t] : o_matched_buyer[t-1]) &&
    (o_matched_seller[t] = is_open(o_state_b2[t-1], o_state_b1[t-1], o_state_b0[t-1]) & 
                           i_create_order[t] ? i_seller_id[t] : o_matched_seller[t-1]) &&
    
    # ==== RELEASE CONDITIONS ====
    
    # Release to buyer: verified OR dispute resolved for buyer
    (o_release_buyer[t] = 
        (is_verified(o_state_b2[t-1], o_state_b1[t-1], o_state_b0[t-1])) |
        (is_disputed(o_state_b2[t-1], o_state_b1[t-1], o_state_b0[t-1]) & 
         i_dispute_resolved_buyer[t])) &&
    
    # Refund to seller: timeout OR cancel OR dispute resolved for seller
    (o_refund_seller[t] = 
        (is_matched(o_state_b2[t-1], o_state_b1[t-1], o_state_b0[t-1]) &
         timed_out(o_escrow_lock_time[t-1], i_current_time[t], i_lock_duration[t])) |
        (is_proving(o_state_b2[t-1], o_state_b1[t-1], o_state_b0[t-1]) &
         (i_zkp_invalid[t] | timed_out(o_escrow_lock_time[t-1], i_current_time[t], i_lock_duration[t]))) |
        (is_disputed(o_state_b2[t-1], o_state_b1[t-1], o_state_b0[t-1]) & 
         i_dispute_resolved_seller[t]) |
        (is_open(o_state_b2[t-1], o_state_b1[t-1], o_state_b0[t-1]) & i_cancel_order[t])) &&
    
    # ==== FEE CALCULATION ====
    
    # Protocol fee (only on successful trades)
    (o_protocol_fee[t] = o_release_buyer[t] ? 
                         calc_fee(o_escrowed_amount[t-1], i_protocol_fee_bps[t]) :
                         {0}:bv[16]) &&
    
    # Burn (50% of protocol fee for deflation)
    (o_burn_amount[t] = o_protocol_fee[t] / {2}:bv[16]) &&
    
    # ==== SLASHING ====
    
    # Slash deposit on proven bad behavior
    (o_slash_deposit[t] = 
        (is_disputed(o_state_b2[t-1], o_state_b1[t-1], o_state_b0[t-1]) & 
         (i_dispute_resolved_buyer[t] | i_dispute_resolved_seller[t]))) &&
    
    # ==== INVARIANT MONITORS ====
    
    # FUNDS SAFE: Escrow either locked or properly released
    (o_funds_safe[t] = 
        (o_escrowed_amount[t] > {0}:bv[32]) |
        (o_escrowed_amount[t] = {0}:bv[32] & 
         (o_release_buyer[t] | o_refund_seller[t] | 
          is_idle(o_state_b2[t], o_state_b1[t], o_state_b0[t])))) &&
    
    # NO DOUBLE RELEASE: Cannot release to both buyer and seller
    (o_no_double_release[t] = (o_release_buyer[t] & o_refund_seller[t])') &&
    
    # TIMEOUT PROTECTED: Eventually exits active state
    (o_timeout_protected[t] = 
        (escrow_active(o_state_b2[t], o_state_b1[t], o_state_b0[t])') |
        (i_current_time[t] - o_escrow_lock_time[t] <= i_lock_duration[t])) &&
    
    # STATE VALID: Only valid state combinations
    (o_state_valid[t] = 
        is_idle(o_state_b2[t], o_state_b1[t], o_state_b0[t]) |
        is_open(o_state_b2[t], o_state_b1[t], o_state_b0[t]) |
        is_matched(o_state_b2[t], o_state_b1[t], o_state_b0[t]) |
        is_proving(o_state_b2[t], o_state_b1[t], o_state_b0[t]) |
        is_verified(o_state_b2[t], o_state_b1[t], o_state_b0[t]) |
        is_settled(o_state_b2[t], o_state_b1[t], o_state_b0[t]) |
        is_disputed(o_state_b2[t], o_state_b1[t], o_state_b0[t]) |
        is_cancelled(o_state_b2[t], o_state_b1[t], o_state_b0[t]))
)

# ============================================================================
# FORMAL GUARANTEES (Tau proves these)
# ============================================================================
#
# 1. ESCROW SAFETY
#    - Funds locked IFF in active escrow state
#    - Release happens exactly once
#    - No state where funds are lost
#
# 2. LIVENESS
#    - Every active escrow eventually terminates
#    - Timeout guarantees seller refund
#    - No stuck states
#
# 3. FAIRNESS
#    - Buyer gets funds IFF proof valid
#    - Seller gets refund IFF no valid proof by timeout
#    - Dispute resolution is final
#
# 4. ATOMICITY
#    - State transitions are atomic
#    - No partial releases
#    - Fee deduction is deterministic

# ============================================================================
# INTEGRATION WITH ZKP VERIFIERS
# ============================================================================
#
# The specification accepts i_zkp_valid / i_zkp_invalid as BOOLEAN inputs.
# These come from external verifiers:
#
# 1. zkTLS (Reclaim Protocol)
#    - Proves TLS session contents (payment confirmation)
#    - Daemon calls Reclaim API, outputs boolean
#
# 2. MPC-TLS (TLSNotary)
#    - Multi-party TLS session proof
#    - Notary service outputs boolean
#
# 3. zkEmail
#    - Proves email receipt (payment confirmation)
#    - Email header verification outputs boolean
#
# 4. TEE (Trusted Execution Environment)
#    - Hardware attestation
#    - TEE outputs boolean
#
# DAEMON RESPONSIBILITIES:
# - Collect proof from buyer
# - Submit to appropriate verifier
# - Translate verification result to i_zkp_valid/i_zkp_invalid
# - Maintain timeout countdown
# - Execute escrow release via ledger

# ============================================================================
# STATE MACHINE DIAGRAM
# ============================================================================
#
#     ┌──────┐  create   ┌──────┐  match    ┌─────────┐
#     │ IDLE │──────────▶│ OPEN │──────────▶│ MATCHED │
#     └──────┘           └──────┘           └─────────┘
#        ▲                  │                    │
#        │               cancel              submit_proof
#        │                  │                    │
#        │                  ▼                    ▼
#     ┌──────────┐      ┌──────────┐        ┌─────────┐
#     │CANCELLED │◀─────│ timeout  │◀───────│ PROVING │
#     └──────────┘      └──────────┘        └─────────┘
#                                               │    │
#                          zkp_invalid──────────┘    │zkp_valid
#                                                    │
#                       dispute  ┌──────────┐        ▼
#                    ┌──────────▶│ DISPUTED │   ┌──────────┐
#                    │           └──────────┘   │ VERIFIED │
#                    │               │          └──────────┘
#                    │         resolve           │
#                    │               │           │release
#                    │               ▼           ▼
#                    │           ┌─────────┐ ┌─────────┐
#                    └───────────│ SETTLED │ │ SETTLED │
#                                └─────────┘ └─────────┘

