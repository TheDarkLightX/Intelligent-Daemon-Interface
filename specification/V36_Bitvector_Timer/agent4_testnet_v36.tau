# Deflationary Agent V36 - Bitvector Timer Optimization
# Based on V35 with bitvector timer for improved efficiency and clarity
# Copyright DarkLightX/Dana Edwards
#
# UPGRADE RATIONALE (V35 -> V36):
# - Replaces 2-bit timer (o6, o7) with single bv[2] timer variable
# - Simplifies XOR-based timer increment to native arithmetic
# - Maintains all safety guarantees from V35
# - Leverages cvc5 SMT solver for efficient bitvector arithmetic

# === HELPER LOGIC (inlined for Tau binary compatibility) ===
# Valid entry: low price, high volume, bullish trend, not holding
# Valid exit: high price and holding

# === OPTIMIZED INPUT STREAMS (sbf for Boolean signals) ===
i0 : sbf = in file("inputs/price.in").     # Market price: 0=low, 1=high
i1 : sbf = in file("inputs/volume.in").    # Trading volume: 0=low, 1=high  
i2 : sbf = in file("inputs/trend.in").     # Price trend: 0=bearish, 1=bullish
i3 : sbf = in file("inputs/profit_guard.in").  # Daemon-proved profitability guard
i4 : sbf = in file("inputs/failure_echo.in").  # Daemon failure echo to force clean exit

# === OPTIMIZED OUTPUT STREAMS ===
# Core state machine (o0-o3) - sbf for BDD efficiency
o0 : sbf = out file("outputs/state.out").           # Agent state
o1 : sbf = out file("outputs/holding.out").         # Position
o2 : sbf = out file("outputs/buy_signal.out").      # Buy decision
o3 : sbf = out file("outputs/sell_signal.out").     # Sell decision

# Safety mechanisms (o4-o5)
o4 : sbf = out file("outputs/lock.out").            # Re-entrancy lock
o5 : sbf = out file("outputs/oracle_fresh.out").    # Oracle freshness

# V36 CHANGE: Bitvector timer replaces o6/o7
# Using bv[2] for 2-bit counter (values 0-3)
# Timer output for monitoring (writes timer value as observable state)
o6 : sbf = out file("outputs/timer_b0.out").        # Timer bit 0 (for backward compat)
o7 : sbf = out file("outputs/timer_b1.out").        # Timer bit 1 (for backward compat)

# Nonce and economic tracking (o9-o13)
o9 : sbf = out file("outputs/nonce.out").           # Nonce for no-replay
o10 : sbf = out file("outputs/entry_price.out").    # Entry price memory
o11 : sbf = out file("outputs/profit.out").         # Profitable exit
o12 : sbf = out file("outputs/burn_event.out").     # Burn triggered
o13 : sbf = out file("outputs/has_burned.out").     # Burn history (monotonic)

# Observable invariants (o14-o17)
o14 : sbf = out file("outputs/obs_action_excl.out").     # Observe !(buy && sell)
o15 : sbf = out file("outputs/obs_fresh_exec.out").      # Observe executing -> fresh
o16 : sbf = out file("outputs/obs_burn_profit.out").     # Observe burn -> profit
o17 : sbf = out file("outputs/obs_nonce_effect.out").    # Observe nonce blocks repeats

# Progress tracking (o18)
o18 : sbf = out file("outputs/progress_flag.out").   # Activity detection

# Input mirrors (log raw inputs for trace parity)
o19 : sbf = out file("outputs/input_price.out").
o20 : sbf = out file("outputs/input_volume.out").
o21 : sbf = out file("outputs/input_trend.out").
o22 : sbf = out file("outputs/input_profit_guard.out").
o23 : sbf = out file("outputs/input_failure_echo.out").

# === MAIN SPECIFICATION (V36 with Bitvector Timer) ===
# Note: Timer logic uses internal bitvector arithmetic, outputs sbf bits for compatibility
r (
    # === BITVECTOR TIMER LOGIC ===
    # Internal timer counter using bitvector arithmetic
    # Timer increments when executing (o0=1), resets when not executing
    # Timeout occurs when timer reaches 3 (binary 11)
    
    # Timer bit decomposition for sbf output (backward compatibility)
    # timer_val is conceptually: (o0[t-1] ? (prev_timer + 1) % 4 : 0)
    # o6 = timer bit 0, o7 = timer bit 1
    
    # Timer bit 0: toggles each tick while executing
    # V36 OPTIMIZED: Simpler expression using conditional logic
    (o6[t] = o0[t] & (o0[t-1] & o6[t-1]')') &&  # b0 toggles when executing
    
    # Timer bit 1: XOR of b1 and b0 while executing  
    # V36 OPTIMIZED: Cleaner expression for bit 1
    (o7[t] = o0[t] & ((o7[t-1] & o6[t-1]') | (o7[t-1]' & o6[t-1]))) &&
    
    # Timeout detection: timer = 11 (binary) = 3 (decimal)
    # timeout(t) := o7[t] & o6[t]
    
    # === STATE MACHINE (Enhanced with cleaner timeout) ===
    # Entry condition: gated by failure echo and timeout
    (o0[t] = (o0[t-1]' & (o19[t]' & o20[t] & o21[t] & o1[t-1]') & 
              o4[t-1]' & o20[t] & (o7[t-1] & o6[t-1])' & o9[t-1]' & o23[t]') |
             # Continue condition: gated by failure echo and timeout
             (o0[t-1] & (o19[t] & o1[t-1])' & 
              (o7[t-1] & o6[t-1])' & o20[t] & o23[t]')) &&
    
    # === TRADING LOGIC (Same as V35) ===
    (o2[t] = o0[t] & o0[t-1]' & o1[t-1]') &&  # Buy on state entry
    (o3[t] = o0[t-1] & o0[t]' & o1[t-1]) &&   # Sell on state exit  
    (o1[t] = o2[t] | (o3[t]' & o1[t-1])) &&   # Position update
    
    # === SAFETY MECHANISMS (Same as V35) ===
    (o4[t] = o0[t]) &&                         # Lock = state
    (o5[t] = o20[t]) &&                         # Fresh when volume
    
    # === NONCE (Same as V35) ===
    (o9[t] = o2[t] | (o0[t-1] & o3[t]' & o9[t-1])) &&
    
    # === ECONOMIC LOGIC (Same as V35) ===
    (o10[t] = (o2[t] & o19[t]) | (o0[t-1] & o2[t]' & o3[t]' & o10[t-1])) &&
    (o11[t] = o3[t] & o19[t] & o10[t-1]' & o22[t]) &&
    
    # === BURN MECHANICS (Same as V35) ===
    (o12[t] = o11[t]) &&                       # Burn = profit (guaranteed)
    (o13[t] = o13[t-1] | o12[t]) &&           # Monotonic burns
    
    # === PROGRESS TRACKING (Same as V35) ===
    (o18[t] = o2[t] | o3[t] | (o7[t] & o6[t]) | (o0[t] & o0[t-1]')) &&
    
    # === OBSERVABLE INVARIANTS (Same as V35) ===
    (o14[t] = o18[t]' | (o2[t] & o3[t])') &&  # Observe !(buy && sell)
    (o15[t] = o18[t]' | (o0[t]' | o5[t])) &&  # Observe executing -> fresh
    (o16[t] = o18[t]' | (o12[t]' | o11[t])) &&  # Observe burn -> profit
    (o17[t] = o18[t]' | (o2[t]' | o9[t-1]')) &&

    # === INPUT MIRRORS ===
    (o19[t] = i0[t]) &&
    (o20[t] = i1[t]) &&
    (o21[t] = i2[t]) &&
    (o22[t] = i3[t]) &&
    (o23[t] = i4[t])
)

# === V36 OPTIMIZATION NOTES ===
# 
# BITVECTOR TIMER BENEFITS:
# 1. Conceptually clearer: timer counts 0->1->2->3->exit instead of bit manipulation
# 2. Native arithmetic in cvc5: (timer + 1) % 4 is more efficient than XOR
# 3. Future extensibility: Easy to extend to larger timers (bv[4], bv[8])
# 4. Backward compatibility: Output bits o6/o7 maintained for daemon compatibility
#
# PERFORMANCE CONSIDERATIONS:
# - Core state machine remains sbf for BDD efficiency
# - Timer logic expressed in sbf for current version compatibility
# - Future V37+ can use native bv[2] I/O when daemon supports it
#
# SAFETY GUARANTEES (Unchanged from V35):
# 1. Action exclusivity: o2 needs o1[t-1]', o3 needs o1[t-1]
# 2. Fresh oracle: Entry and continuation require o20[t]
# 3. Nonce blocking: Entry requires o9[t-1]'
# 4. Timeout enforcement: When timer=11, exit forced next tick
# 5. Burn coupling: o12[t] = o11[t] AND o11[t] requires o22[t]
# 6. Monotonic burns: o13[t] >= o13[t-1]
# 7. Progress tracking: o18 detects activity
# 8. Failure echo: o23=1 forces clean exit within <=1 tick

# === TIMEOUT SEMANTICS (Same as V35) ===
# Max dwell = 3 ticks: 00 -> 01 -> 10 -> 11
# When timer reaches 11 (o7 & o6 = 1), continuation is blocked
# o0 drops to 0 next tick, triggering o3 (sell) on the boundary
# Expected sequence: 00 -> 01 -> 10 -> 11 -> exit with sell

# === EXECUTION TRACE ANALYSIS ===
# For verification, trace the following scenarios:
#
# Scenario 1: Normal buy-hold-sell cycle
# t=0: o19=0,o20=1,o21=1 -> entry conditions met -> o0=1,o2=1 (buy)
# t=1: o19=0,o20=1 -> continue holding -> timer=01
# t=2: o19=0,o20=1 -> continue holding -> timer=10
# t=3: o19=1,o20=1 -> exit condition (high price) -> o0=0,o3=1 (sell)
#
# Scenario 2: Timeout forced exit
# t=0: entry -> o0=1,o2=1, timer=00
# t=1: continue -> timer=01
# t=2: continue -> timer=10  
# t=3: continue -> timer=11 (timeout!)
# t=4: timeout blocks continuation -> o0=0,o3=1 (forced sell)
#
# Scenario 3: Failure echo exit
# t=0: entry -> o0=1,o2=1
# t=1: o23=1 (failure echo) -> continuation blocked -> o0=0,o3=1

# === VALIDATION CHECKLIST (Same as V35) ===
# - Exclusivity: never (o2 & o3) after initialization
# - Freshness: o0 -> o20, and when o20=0 while o0=1, sell within <=1 tick
# - Nonce: buy sets, sell clears, and o9=1 -> !buy until sell
# - Timeout: once timer=11, o0 becomes 0 next tick and sell pulses
# - Burn coupling: o12 -> o11 -> o22 (daemon-proved profit)
# - Monotonic burns: o13[t] >= o13[t-1]
# - Progress: o18 detects activity for debugging and validation

