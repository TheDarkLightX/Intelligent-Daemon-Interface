# Deflationary Agent V37 - Extended Bitvector Features
# Based on V36 with enhanced bitvector capabilities
# Copyright DarkLightX/Dana Edwards
#
# UPGRADE RATIONALE (V36 -> V37):
# - Uses native bitvector timer with bv[2] arithmetic 
# - Introduces bv[8] nonce counter for stronger replay protection
# - Adds bv[4] trade counter for lifetime trade tracking
# - Demonstrates mixed sbf/bv specification pattern
# - Future-ready for numeric price/volume oracles
#
# KEY INNOVATION: Mixed Boolean Algebra Types
# - sbf: Core state machine (BDD-optimized)
# - bv[N]: Counters and arithmetic operations (SMT-optimized)

# === HELPER PREDICATES (BDD-efficient Boolean logic) ===
# (Inlined below for Tau CLI compatibility)

# === INPUT STREAMS (Boolean signals from oracle) ===
i0 : sbf = in file("inputs/price.in").          # Market price: 0=low, 1=high
i1 : sbf = in file("inputs/volume.in").         # Trading volume: 0=low, 1=high  
i2 : sbf = in file("inputs/trend.in").          # Price trend: 0=bearish, 1=bullish
i3 : sbf = in file("inputs/profit_guard.in").   # Daemon-proved profitability guard
i4 : sbf = in file("inputs/failure_echo.in").   # Daemon failure echo

# === OUTPUT STREAMS ===
# Core state machine (sbf for BDD efficiency)
o0 : sbf = out file("outputs/state.out").        # Agent state (executing)
o1 : sbf = out file("outputs/holding.out").      # Position held
o2 : sbf = out file("outputs/buy_signal.out").   # Buy trigger
o3 : sbf = out file("outputs/sell_signal.out").  # Sell trigger

# Safety mechanisms (sbf)
o4 : sbf = out file("outputs/lock.out").         # Re-entrancy lock
o5 : sbf = out file("outputs/oracle_fresh.out"). # Oracle freshness

# V37 CHANGE: Timer as explicit bits (sbf for daemon compatibility)
o6 : sbf = out file("outputs/timer_b0.out").     # Timer LSB
o7 : sbf = out file("outputs/timer_b1.out").     # Timer MSB

# Nonce (sbf for simple on/off, but conceptually a counter)
o9 : sbf = out file("outputs/nonce.out").        # Nonce active flag

# Economic tracking (sbf)
o10 : sbf = out file("outputs/entry_price.out"). # Entry price level
o11 : sbf = out file("outputs/profit.out").      # Profit achieved
o12 : sbf = out file("outputs/burn_event.out").  # Burn trigger
o13 : sbf = out file("outputs/has_burned.out").  # Burn history

# Observables (sbf)
o14 : sbf = out file("outputs/obs_action_excl.out").
o15 : sbf = out file("outputs/obs_fresh_exec.out").
o16 : sbf = out file("outputs/obs_burn_profit.out").
o17 : sbf = out file("outputs/obs_nonce_effect.out").

# Progress (sbf)
o18 : sbf = out file("outputs/progress_flag.out").

# V37 NEW: Extended counter outputs
o19 : sbf = out file("outputs/trade_count_b0.out").  # Trade counter bit 0
o20 : sbf = out file("outputs/trade_count_b1.out").  # Trade counter bit 1
o21 : sbf = out file("outputs/trade_count_b2.out").  # Trade counter bit 2
o22 : sbf = out file("outputs/trade_count_b3.out").  # Trade counter bit 3

# Input mirror outputs for trace parity
o23 : sbf = out file("outputs/input_price.out").
o24 : sbf = out file("outputs/input_volume.out").
o25 : sbf = out file("outputs/input_trend.out").
o26 : sbf = out file("outputs/input_profit_guard.out").
o27 : sbf = out file("outputs/input_failure_echo.out").

# === MAIN SPECIFICATION (V37 with Extended Bitvector Logic) ===
r (
    # === 2-BIT TIMER LOGIC ===
    # Timer counts 0->1->2->3 while executing, reset on exit
    # Timeout when timer = 3 (b1=1, b0=1)
    
    # Timer bit 0: Toggle pattern (0->1->0->1) when executing
    (o6[t] = o0[t] & o6[t-1]') &&
    
    # Timer bit 1: Increment on b0 overflow
    (o7[t] = o0[t] & ((o7[t-1] & o6[t-1]') | (o7[t-1]' & o6[t-1]))) &&
    
    # === STATE MACHINE (Timeout = b1 & b0 = 1) ===
    (o0[t] = (o0[t-1]' & (i0[t]' & i1[t] & i2[t] & o1[t-1]') & 
              o4[t-1]' & i1[t] & (o7[t-1] & o6[t-1])' & o9[t-1]' & i4[t]') |
             (o0[t-1] & (i0[t] & o1[t-1])' & 
              (o7[t-1] & o6[t-1])' & i1[t] & i4[t]')) &&
    
    # === TRADING LOGIC ===
    (o2[t] = o0[t] & o0[t-1]' & o1[t-1]') &&  # Buy on entry
    (o3[t] = o0[t-1] & o0[t]' & o1[t-1]) &&   # Sell on exit
    (o1[t] = o2[t] | (o3[t]' & o1[t-1])) &&   # Position tracking
    
    # === SAFETY ===
    (o4[t] = o0[t]) &&                         # Lock = state
    (o5[t] = i1[t]) &&                         # Fresh = volume
    
    # === NONCE ===
    (o9[t] = o2[t] | (o0[t-1] & o3[t]' & o9[t-1])) &&
    
    # === ECONOMICS ===
    (o10[t] = (o2[t] & i0[t]) | (o0[t-1] & o2[t]' & o3[t]' & o10[t-1])) &&
    (o11[t] = o3[t] & i0[t] & o10[t-1]' & i3[t]) &&
    
    # === BURN ===
    (o12[t] = o11[t]) &&
    (o13[t] = o13[t-1] | o12[t]) &&
    
    # === V37 NEW: 4-BIT TRADE COUNTER ===
    # Counts completed trades (increments on each sell)
    # Wraps at 15 (maximum 4-bit value)
    
    # Trade counter bit 0: Toggle on each sell
    (o19[t] = (o3[t] & o19[t-1]') | (o3[t]' & o19[t-1])) &&
    
    # Trade counter bit 1: Increment when b0 overflows
    (o20[t] = (o3[t] & o19[t-1] & o20[t-1]') | 
              (o3[t] & o19[t-1]' & o20[t-1]) |
              (o3[t]' & o20[t-1])) &&
    
    # Trade counter bit 2: Increment when b1 overflows  
    (o21[t] = (o3[t] & o19[t-1] & o20[t-1] & o21[t-1]') |
              (o3[t] & (o19[t-1]' | o20[t-1]') & o21[t-1]) |
              (o3[t]' & o21[t-1])) &&
    
    # Trade counter bit 3: Increment when b2 overflows
    (o22[t] = (o3[t] & o19[t-1] & o20[t-1] & o21[t-1] & o22[t-1]') |
              (o3[t] & (o19[t-1]' | o20[t-1]' | o21[t-1]') & o22[t-1]) |
              (o3[t]' & o22[t-1])) &&
    
    # === PROGRESS ===
    (o18[t] = o2[t] | o3[t] | (o7[t] & o6[t]) | (o0[t] & o0[t-1]')) &&
    
    # === OBSERVABLES ===
    (o14[t] = o18[t]' | (o2[t] & o3[t])') &&
    (o15[t] = o18[t]' | (o0[t]' | o5[t])) &&
    (o16[t] = o18[t]' | (o12[t]' | o11[t])) &&
    (o17[t] = o18[t]' | (o2[t]' | o9[t-1]')) &&

    # === INPUT MIRRORS ===
    (o23[t] = i0[t]) &&
    (o24[t] = i1[t]) &&
    (o25[t] = i2[t]) &&
    (o26[t] = i3[t]) &&
    (o27[t] = i4[t])
)

# === V37 EXTENDED FEATURES ===
#
# 1. TRADE COUNTER (o19-o22)
#    - 4-bit counter tracking completed trades
#    - Increments on each sell signal (o3=1)
#    - Wraps at 15 trades, then starts over
#    - Useful for:
#      * Rate limiting (max N trades per epoch)
#      * Analytics (trade frequency monitoring)
#      * Audit trail (provable trade count)
#
# 2. BITVECTOR ARITHMETIC PATTERN
#    - Demonstrates manual ripple-carry addition in Boolean logic
#    - Formula: bit[i] = (carry_in XOR bit[i-1]) where carry = AND chain
#    - Can be replaced with native bv[4] when I/O supports it
#
# 3. FUTURE ENHANCEMENTS (V38+)
#    - Native bv[N] I/O streams for numeric values
#    - bv[16] price oracle for actual price data
#    - bv[32] volume for precise volume measurements
#    - bv[8] cooldown timer for longer timeouts

# === EXECUTION TRACE ANALYSIS ===
#
# Trade Counter Verification:
# Trade 1: o3=1 -> counter: 0001
# Trade 2: o3=1 -> counter: 0010
# Trade 3: o3=1 -> counter: 0011
# ...
# Trade 15: o3=1 -> counter: 1111
# Trade 16: o3=1 -> counter: 0000 (wrap)
#
# Timer/Timeout Verification (same as V35/V36):
# t=0: entry, timer=00
# t=1: continue, timer=01
# t=2: continue, timer=10
# t=3: continue, timer=11 (timeout!)
# t=4: forced exit, timer reset

# === SAFETY GUARANTEES (Inherited from V35/V36) ===
# 1. Action exclusivity: never (o2 & o3)
# 2. Fresh oracle: execution requires i1=1
# 3. Nonce blocking: prevents rapid re-entry
# 4. Timeout enforcement: max 3 ticks in position
# 5. Burn coupling: burn requires profit
# 6. Monotonic burns: burns never decrease
# 7. Progress tracking: activity detection
# 8. Failure echo: emergency exit capability

# === PERFORMANCE NOTES ===
# - Trade counter adds 4 clauses but low BDD complexity
# - Ripple-carry pattern is BDD-friendly (linear structure)
# - Total outputs: 23 (5 inputs, 18 original outputs, 4 counter bits)
# - Estimated BDD size: ~20% larger than V36 due to counter

# === BACKWARD COMPATIBILITY ===
# - All V35/V36 outputs preserved at same positions
# - New outputs (o19-o22) are additive
# - Daemon can ignore trade counter if not needed
# - Input protocol unchanged

