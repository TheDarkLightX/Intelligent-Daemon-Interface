# Deflationary Agent V35 - Production Ready Kernel (Micro-Optimized)
# Based on V34 with optional micro-optimizations for readability and BDD efficiency
# Copyright DarkLightX/Dana Edwards

# === HELPER PREDICATES (Optimized for BDD efficiency) ===
# Valid entry: low price, high volume, bullish trend, not holding
valid_entry(p, v, t, h) := p' & v & t & h'.

# Valid exit: high price and holding  
valid_exit(p, h) := p & h.

# Timeout detection: factored for readability and BDD optimization
timed_out(b1, b0) := b1 & b0.

# === OPTIMIZED INPUT STREAMS ===
sbf i0 = ifile("inputs/price.in").     # Market price: 0=low, 1=high
sbf i1 = ifile("inputs/volume.in").    # Trading volume: 0=low, 1=high  
sbf i2 = ifile("inputs/trend.in").     # Price trend: 0=bearish, 1=bullish
sbf i3 = ifile("inputs/profit_guard.in").  # Daemon-proved profitability guard
sbf i4 = ifile("inputs/failure_echo.in").  # Daemon failure echo to force clean exit

# === OPTIMIZED OUTPUT STREAMS (21 total: 5 inputs + 16 outputs) ===
# Core state machine (o0-o3)
sbf o0 = ofile("outputs/state.out").           # Agent state
sbf o1 = ofile("outputs/holding.out").         # Position
sbf o2 = ofile("outputs/buy_signal.out").      # Buy decision
sbf o3 = ofile("outputs/sell_signal.out").     # Sell decision

# Safety mechanisms (o4-o7)
sbf o4 = ofile("outputs/lock.out").            # Re-entrancy lock
sbf o5 = ofile("outputs/oracle_fresh.out").    # Oracle freshness
sbf o6 = ofile("outputs/timer_b0.out").        # Timer bit 0 (2-bit counter)
sbf o7 = ofile("outputs/timer_b1.out").        # Timer bit 1 (MSB)

# Nonce and economic tracking (o9-o13)
sbf o9 = ofile("outputs/nonce.out").           # Nonce for no-replay
sbf o10 = ofile("outputs/entry_price.out").    # Entry price memory
sbf o11 = ofile("outputs/profit.out").         # Profitable exit
sbf o12 = ofile("outputs/burn_event.out").     # Burn triggered
sbf o13 = ofile("outputs/has_burned.out").     # Burn history (monotonic)

# Observable invariants (o14-o17)
sbf o14 = ofile("outputs/obs_action_excl.out").     # Observe !(buy && sell)
sbf o15 = ofile("outputs/obs_fresh_exec.out").      # Observe executing -> fresh
sbf o16 = ofile("outputs/obs_burn_profit.out").     # Observe burn -> profit
sbf o17 = ofile("outputs/obs_nonce_effect.out").    # Observe nonce blocks repeats

# Progress tracking (o18)
sbf o18 = ofile("outputs/progress_flag.out").   # Activity detection

# === MAIN SPECIFICATION (Production Ready with Micro-Optimizations) ===
r (
    # === OPTIMIZED STATE MACHINE (With factored timeout and enhanced progress) ===
    # Entry condition: gated by failure echo, factored timeout
    (o0[t] = (o0[t-1]' & valid_entry(i0[t], i1[t], i2[t], o1[t-1]) & 
              o4[t-1]' & i1[t] & timed_out(o7[t-1], o6[t-1])' & o9[t-1]' & i4[t]') |
             # Continue condition: gated by failure echo, factored timeout
             (o0[t-1] & valid_exit(i0[t], o1[t-1])' & 
              timed_out(o7[t-1], o6[t-1])' & i1[t] & i4[t]')) &&
    
    # === OPTIMIZED TRADING LOGIC (Early gating for BDD efficiency) ===
    (o2[t] = o0[t] & o0[t-1]' & o1[t-1]') &&  # Buy on state entry
    (o3[t] = o0[t-1] & o0[t]' & o1[t-1]) &&   # Sell on state exit  
    (o1[t] = o2[t] | (o3[t]' & o1[t-1])) &&   # Position update
    
    # === OPTIMIZED SAFETY MECHANISMS (Direct assignment) ===
    (o4[t] = o0[t]) &&                         # Lock = state
    (o5[t] = i1[t]) &&                         # Fresh when volume
    
    # === OPTIMIZED 2-BIT TIMER (BDD-friendly implementation) ===
    # Timer bit 0: optimized for minimal BDD size
    (o6[t] = o0[t] & o6[t-1]') &&              # Timer bit 0: b0_next = not b0_prev
    # Timer bit 1: optimized XOR implementation
    (o7[t] = o0[t] & ((o7[t-1] & o6[t-1]') | (o7[t-1]' & o6[t-1]))) &&  # Timer bit 1: b1_next = b1 XOR b0
    
    # === OPTIMIZED NONCE (Gated by execution state) ===
    # Nonce: carry only while executing
    (o9[t] = o2[t] | (o0[t-1] & o3[t]' & o9[t-1])) &&
    
    # === OPTIMIZED ECONOMIC LOGIC (With daemon profit guard) ===
    # Entry price: carry only while executing and not selling
    (o10[t] = (o2[t] & i0[t]) | (o0[t-1] & o2[t]' & o3[t]' & o10[t-1])) &&
    # Profit: enhanced with daemon profit guard
    (o11[t] = o3[t] & i0[t] & o10[t-1]' & i3[t]) &&
    
    # === OPTIMIZED BURN MECHANICS (Direct coupling) ===
    (o12[t] = o11[t]) &&                       # Burn = profit (guaranteed)
    (o13[t] = o13[t-1] | o12[t]) &&           # Monotonic burns
    
    # === ENHANCED PROGRESS TRACKING (Arms when executing starts) ===
    # Progress flag: arms when executing starts or any activity occurs
    (o18[t] = o2[t] | o3[t] | (o7[t] & o6[t]) | (o0[t] & o0[t-1]')) &&
    
    # === OPTIMIZED OBSERVABLE INVARIANTS (Gated by initialization) ===
    # Action exclusivity: gated by progress
    (o14[t] = o18[t]' | (o2[t] & o3[t])') &&  # Observe !(buy && sell)
    # Fresh oracle: gated by progress
    (o15[t] = o18[t]' | (o0[t]' | o5[t])) &&  # Observe executing -> fresh
    # Burn-profit relationship: gated by progress
    (o16[t] = o18[t]' | (o12[t]' | o11[t])) &&  # Observe burn -> profit
    # Nonce effect: gated by progress
    (o17[t] = o18[t]' | (o2[t]' | o9[t-1]'))  # Observe nonce blocks repeats
)

# === PRODUCTION READY OPTIMIZATION STRATEGY ===
# 1. EXCLUSIVE USE OF bf EXPRESSIONS: All clauses use bf expressions for optimal BDD efficiency
# 2. XOR AVOIDANCE: No + or ^ operators to prevent BDD explosion
# 3. OPTIMIZED VARIABLE ORDERING: Variables ordered for minimal BDD size
# 4. REDUCED CLAUSE COMPLEXITY: Factored common subexpressions into helper predicates
# 5. EARLY GATING: Conditions applied early for better BDD pruning
# 6. SIMPLE CONJUNCTIVE STRUCTURE: All clauses use && for optimal parsing
# 7. MINIMAL HELPER PREDICATES: Only essential helpers to avoid overhead
# 8. DIRECT BOOLEAN OPERATIONS: Use &, |, ' exclusively for BDD efficiency
# 9. OPTIMIZED TIMER: 2-bit timer with BDD-friendly implementation
# 10. DAEMON INTEGRATION: profit_guard and failure_echo for production safety
# 11. STATE GATING: Nonce and entry price carry only while executing
# 12. INITIALIZATION DISCIPLINE: Progress flag gates observable invariants
# 13. FACTORED TIMEOUT: Helper predicate for readability and BDD optimization
# 14. ENHANCED PROGRESS: Arms when executing starts for better monitoring

# === BDD OPTIMIZATION INSIGHTS APPLIED ===
# - XOR operations cause BDD explosion: avoided + and ^ operators
# - bf expressions more efficient than wff in r() blocks: used exclusively
# - DNF conversion automatic: leveraged for optimization
# - Variable ordering affects BDD size: optimized ordering
# - Temporal operators add complexity: minimized usage
# - Helper predicates cached: used for complex subexpressions
# - Clause count matters more than variable count: maintained 16 clauses
# - Simple conjunctive structure optimal: used throughout
# - State gating reduces BDD size: nonce and entry price gated by execution
# - Factored timeout reduces duplication: timed_out() helper predicate
# - Enhanced progress flag: arms immediately when executing starts

# === TIMEOUT SEMANTICS ===
# Max dwell = 3 ticks: 00 -> 01 -> 10 -> 11
# When timer reaches 11 (o7 & o6 = 1), continuation is blocked
# o0 drops to 0 next tick, triggering o3 (sell) on the boundary
# Expected sequence: 00 -> 01 -> 10 -> 11 -> exit with sell
# Factored timeout: timed_out(o7[t-1], o6[t-1]) for clarity and BDD optimization

# === SAFETY GUARANTEES (Enhanced) ===
# 1. Action exclusivity: o2 needs o1[t-1]', o3 needs o1[t-1]
# 2. Fresh oracle: Entry and continuation require i1[t]
# 3. Nonce blocking: Entry requires o9[t-1]' (gated by execution state)
# 4. Timeout enforcement: When timed_out(o7, o6)=1, exit forced next tick
# 5. Burn coupling: o12[t] = o11[t] AND o11[t] requires i3[t] (daemon approval)
# 6. Monotonic burns: o13[t] >= o13[t-1]
# 7. Progress tracking: o18 detects activity and executing starts
# 8. Failure echo: i4=1 forces clean exit within <=1 tick
# 9. Daemon profit guard: i3 required for profit/burn events

# === INITIALIZATION DISCIPLINE ===
# All latches are deterministic at t=0:
# - o9[t] = o2[t] | (o0[t-1] & o3[t]' & o9[t-1]) - only carries when executing
# - o10[t] = (o2[t] & i0[t]) | (o0[t-1] & o2[t]' & o3[t]' & o10[t-1]) - only carries when executing
# - o18[t] = o2[t] | o3[t] | (o7[t] & o6[t]) | (o0[t] & o0[t-1]') - progress tracking with executing start
# - o6[t] = o0[t] & o6[t-1]' - timer bit 0 (0 at t=0)
# - o7[t] = o0[t] & ((o7[t-1] & o6[t-1]') | (o7[t-1]' & o6[t-1])) - timer bit 1 (0 at t=0)
#
# Machine starts with: o0=0, o1=0, o6=0, o7=0, o9=0, o10=0, o18=0
# No undefined carryovers at t=0
# Observable invariants gated by o18 to prevent t=0 artifacts

# === VALIDATION CHECKLIST ===
# - Exclusivity: never (o2 & o3) after initialization
# - Freshness: o0 -> i1, and when i1=0 while o0=1, sell within <=1 tick
# - Nonce: buy sets, sell clears, and o9=1 -> !buy until sell (gated by execution)
# - Timeout: once timed_out(o7, o6)=1, o0 becomes 0 next tick and sell pulses
# - Burn coupling: o12 -> o11 -> i3 (daemon-proved profit)
# - Monotonic burns: o13[t] >= o13[t-1]
# - Progress: o18 detects activity and executing starts for debugging and validation
# - Failure echo: i4=1 forces clean exit within <=1 tick
# - Daemon profit guard: i3 required for profit/burn events
# - State gating: Nonce and entry price carry only while executing
# - BDD efficiency: All optimizations applied for minimal BDD size
# - Initialization: Clean startup with no t=0 artifacts
# - Factored timeout: timed_out() helper for clarity and optimization 