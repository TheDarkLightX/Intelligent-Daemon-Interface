"""Proof bundle helpers for IDI zk workflows.

Manages proof generation and verification for manifest-based ZK proofs.
Supports both stub (SHA-256 only) and zkVM provers (Risc0).

Security Properties:
- Integrity: Proof digest binds manifest and stream data
- Determinism: Same inputs always produce same digest
- Verifiability: Anyone can verify proofs without proving key

Dependencies: hashlib, json, subprocess
"""

from __future__ import annotations

import hashlib
import json
import shlex
import subprocess
import time
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Optional

# Security constants
MAX_RECEIPT_SIZE_BYTES = 512 * 1024  # 512KB limit for receipt files
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_trampoline(orig, mutants, call_args, call_kwargs, self_arg = None):
    """Forward call to original or mutated function, depending on the environment"""
    import os
    mutant_under_test = os.environ['MUTANT_UNDER_TEST']
    if mutant_under_test == 'fail':
        from mutmut.__main__ import MutmutProgrammaticFailException
        raise MutmutProgrammaticFailException('Failed programmatically')      
    elif mutant_under_test == 'stats':
        from mutmut.__main__ import record_trampoline_hit
        record_trampoline_hit(orig.__module__ + '.' + orig.__name__)
        result = orig(*call_args, **call_kwargs)
        return result
    prefix = orig.__module__ + '.' + orig.__name__ + '__mutmut_'
    if not mutant_under_test.startswith(prefix):
        result = orig(*call_args, **call_kwargs)
        return result
    mutant_name = mutant_under_test.rpartition('.')[-1]
    if self_arg is not None:
        # call to a class method where self is not bound
        result = mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = mutants[mutant_name](*call_args, **call_kwargs)
    return result


def x__validate_path_safety__mutmut_orig(path: Path, base_dir: Optional[Path] = None) -> None:
    """Validate that a path is safe to access (no traversal, reasonable length).

    If base_dir is provided, the resolved path must remain within base_dir.
    """
    try:
        # Resolve to absolute path to check for traversal
        resolved = path.resolve()

        # Check for path traversal (should not go above base_dir if provided)
        if base_dir is not None:
            base_dir_resolved = base_dir.resolve()
            if not resolved.is_relative_to(base_dir_resolved):
                raise ValueError(f"Path traversal detected: {path} (base_dir={base_dir_resolved})")

        # Check path length (prevent extremely long paths)
        if len(str(resolved)) > 4096:  # 4KB limit for path length
            raise ValueError(f"Path too long: {path}")

        # Check for null bytes in path (potential security issue)
        if "\x00" in str(path):
            raise ValueError(f"Invalid null byte in path: {path}")

    except (OSError, RuntimeError) as e:
        raise ValueError(f"Invalid path: {path} - {e}")


def x__validate_path_safety__mutmut_1(path: Path, base_dir: Optional[Path] = None) -> None:
    """Validate that a path is safe to access (no traversal, reasonable length).

    If base_dir is provided, the resolved path must remain within base_dir.
    """
    try:
        # Resolve to absolute path to check for traversal
        resolved = None

        # Check for path traversal (should not go above base_dir if provided)
        if base_dir is not None:
            base_dir_resolved = base_dir.resolve()
            if not resolved.is_relative_to(base_dir_resolved):
                raise ValueError(f"Path traversal detected: {path} (base_dir={base_dir_resolved})")

        # Check path length (prevent extremely long paths)
        if len(str(resolved)) > 4096:  # 4KB limit for path length
            raise ValueError(f"Path too long: {path}")

        # Check for null bytes in path (potential security issue)
        if "\x00" in str(path):
            raise ValueError(f"Invalid null byte in path: {path}")

    except (OSError, RuntimeError) as e:
        raise ValueError(f"Invalid path: {path} - {e}")


def x__validate_path_safety__mutmut_2(path: Path, base_dir: Optional[Path] = None) -> None:
    """Validate that a path is safe to access (no traversal, reasonable length).

    If base_dir is provided, the resolved path must remain within base_dir.
    """
    try:
        # Resolve to absolute path to check for traversal
        resolved = path.resolve()

        # Check for path traversal (should not go above base_dir if provided)
        if base_dir is None:
            base_dir_resolved = base_dir.resolve()
            if not resolved.is_relative_to(base_dir_resolved):
                raise ValueError(f"Path traversal detected: {path} (base_dir={base_dir_resolved})")

        # Check path length (prevent extremely long paths)
        if len(str(resolved)) > 4096:  # 4KB limit for path length
            raise ValueError(f"Path too long: {path}")

        # Check for null bytes in path (potential security issue)
        if "\x00" in str(path):
            raise ValueError(f"Invalid null byte in path: {path}")

    except (OSError, RuntimeError) as e:
        raise ValueError(f"Invalid path: {path} - {e}")


def x__validate_path_safety__mutmut_3(path: Path, base_dir: Optional[Path] = None) -> None:
    """Validate that a path is safe to access (no traversal, reasonable length).

    If base_dir is provided, the resolved path must remain within base_dir.
    """
    try:
        # Resolve to absolute path to check for traversal
        resolved = path.resolve()

        # Check for path traversal (should not go above base_dir if provided)
        if base_dir is not None:
            base_dir_resolved = None
            if not resolved.is_relative_to(base_dir_resolved):
                raise ValueError(f"Path traversal detected: {path} (base_dir={base_dir_resolved})")

        # Check path length (prevent extremely long paths)
        if len(str(resolved)) > 4096:  # 4KB limit for path length
            raise ValueError(f"Path too long: {path}")

        # Check for null bytes in path (potential security issue)
        if "\x00" in str(path):
            raise ValueError(f"Invalid null byte in path: {path}")

    except (OSError, RuntimeError) as e:
        raise ValueError(f"Invalid path: {path} - {e}")


def x__validate_path_safety__mutmut_4(path: Path, base_dir: Optional[Path] = None) -> None:
    """Validate that a path is safe to access (no traversal, reasonable length).

    If base_dir is provided, the resolved path must remain within base_dir.
    """
    try:
        # Resolve to absolute path to check for traversal
        resolved = path.resolve()

        # Check for path traversal (should not go above base_dir if provided)
        if base_dir is not None:
            base_dir_resolved = base_dir.resolve()
            if resolved.is_relative_to(base_dir_resolved):
                raise ValueError(f"Path traversal detected: {path} (base_dir={base_dir_resolved})")

        # Check path length (prevent extremely long paths)
        if len(str(resolved)) > 4096:  # 4KB limit for path length
            raise ValueError(f"Path too long: {path}")

        # Check for null bytes in path (potential security issue)
        if "\x00" in str(path):
            raise ValueError(f"Invalid null byte in path: {path}")

    except (OSError, RuntimeError) as e:
        raise ValueError(f"Invalid path: {path} - {e}")


def x__validate_path_safety__mutmut_5(path: Path, base_dir: Optional[Path] = None) -> None:
    """Validate that a path is safe to access (no traversal, reasonable length).

    If base_dir is provided, the resolved path must remain within base_dir.
    """
    try:
        # Resolve to absolute path to check for traversal
        resolved = path.resolve()

        # Check for path traversal (should not go above base_dir if provided)
        if base_dir is not None:
            base_dir_resolved = base_dir.resolve()
            if not resolved.is_relative_to(None):
                raise ValueError(f"Path traversal detected: {path} (base_dir={base_dir_resolved})")

        # Check path length (prevent extremely long paths)
        if len(str(resolved)) > 4096:  # 4KB limit for path length
            raise ValueError(f"Path too long: {path}")

        # Check for null bytes in path (potential security issue)
        if "\x00" in str(path):
            raise ValueError(f"Invalid null byte in path: {path}")

    except (OSError, RuntimeError) as e:
        raise ValueError(f"Invalid path: {path} - {e}")


def x__validate_path_safety__mutmut_6(path: Path, base_dir: Optional[Path] = None) -> None:
    """Validate that a path is safe to access (no traversal, reasonable length).

    If base_dir is provided, the resolved path must remain within base_dir.
    """
    try:
        # Resolve to absolute path to check for traversal
        resolved = path.resolve()

        # Check for path traversal (should not go above base_dir if provided)
        if base_dir is not None:
            base_dir_resolved = base_dir.resolve()
            if not resolved.is_relative_to(base_dir_resolved):
                raise ValueError(None)

        # Check path length (prevent extremely long paths)
        if len(str(resolved)) > 4096:  # 4KB limit for path length
            raise ValueError(f"Path too long: {path}")

        # Check for null bytes in path (potential security issue)
        if "\x00" in str(path):
            raise ValueError(f"Invalid null byte in path: {path}")

    except (OSError, RuntimeError) as e:
        raise ValueError(f"Invalid path: {path} - {e}")


def x__validate_path_safety__mutmut_7(path: Path, base_dir: Optional[Path] = None) -> None:
    """Validate that a path is safe to access (no traversal, reasonable length).

    If base_dir is provided, the resolved path must remain within base_dir.
    """
    try:
        # Resolve to absolute path to check for traversal
        resolved = path.resolve()

        # Check for path traversal (should not go above base_dir if provided)
        if base_dir is not None:
            base_dir_resolved = base_dir.resolve()
            if not resolved.is_relative_to(base_dir_resolved):
                raise ValueError(f"Path traversal detected: {path} (base_dir={base_dir_resolved})")

        # Check path length (prevent extremely long paths)
        if len(str(resolved)) >= 4096:  # 4KB limit for path length
            raise ValueError(f"Path too long: {path}")

        # Check for null bytes in path (potential security issue)
        if "\x00" in str(path):
            raise ValueError(f"Invalid null byte in path: {path}")

    except (OSError, RuntimeError) as e:
        raise ValueError(f"Invalid path: {path} - {e}")


def x__validate_path_safety__mutmut_8(path: Path, base_dir: Optional[Path] = None) -> None:
    """Validate that a path is safe to access (no traversal, reasonable length).

    If base_dir is provided, the resolved path must remain within base_dir.
    """
    try:
        # Resolve to absolute path to check for traversal
        resolved = path.resolve()

        # Check for path traversal (should not go above base_dir if provided)
        if base_dir is not None:
            base_dir_resolved = base_dir.resolve()
            if not resolved.is_relative_to(base_dir_resolved):
                raise ValueError(f"Path traversal detected: {path} (base_dir={base_dir_resolved})")

        # Check path length (prevent extremely long paths)
        if len(str(resolved)) > 4097:  # 4KB limit for path length
            raise ValueError(f"Path too long: {path}")

        # Check for null bytes in path (potential security issue)
        if "\x00" in str(path):
            raise ValueError(f"Invalid null byte in path: {path}")

    except (OSError, RuntimeError) as e:
        raise ValueError(f"Invalid path: {path} - {e}")


def x__validate_path_safety__mutmut_9(path: Path, base_dir: Optional[Path] = None) -> None:
    """Validate that a path is safe to access (no traversal, reasonable length).

    If base_dir is provided, the resolved path must remain within base_dir.
    """
    try:
        # Resolve to absolute path to check for traversal
        resolved = path.resolve()

        # Check for path traversal (should not go above base_dir if provided)
        if base_dir is not None:
            base_dir_resolved = base_dir.resolve()
            if not resolved.is_relative_to(base_dir_resolved):
                raise ValueError(f"Path traversal detected: {path} (base_dir={base_dir_resolved})")

        # Check path length (prevent extremely long paths)
        if len(str(resolved)) > 4096:  # 4KB limit for path length
            raise ValueError(None)

        # Check for null bytes in path (potential security issue)
        if "\x00" in str(path):
            raise ValueError(f"Invalid null byte in path: {path}")

    except (OSError, RuntimeError) as e:
        raise ValueError(f"Invalid path: {path} - {e}")


def x__validate_path_safety__mutmut_10(path: Path, base_dir: Optional[Path] = None) -> None:
    """Validate that a path is safe to access (no traversal, reasonable length).

    If base_dir is provided, the resolved path must remain within base_dir.
    """
    try:
        # Resolve to absolute path to check for traversal
        resolved = path.resolve()

        # Check for path traversal (should not go above base_dir if provided)
        if base_dir is not None:
            base_dir_resolved = base_dir.resolve()
            if not resolved.is_relative_to(base_dir_resolved):
                raise ValueError(f"Path traversal detected: {path} (base_dir={base_dir_resolved})")

        # Check path length (prevent extremely long paths)
        if len(str(resolved)) > 4096:  # 4KB limit for path length
            raise ValueError(f"Path too long: {path}")

        # Check for null bytes in path (potential security issue)
        if "XX\x00XX" in str(path):
            raise ValueError(f"Invalid null byte in path: {path}")

    except (OSError, RuntimeError) as e:
        raise ValueError(f"Invalid path: {path} - {e}")


def x__validate_path_safety__mutmut_11(path: Path, base_dir: Optional[Path] = None) -> None:
    """Validate that a path is safe to access (no traversal, reasonable length).

    If base_dir is provided, the resolved path must remain within base_dir.
    """
    try:
        # Resolve to absolute path to check for traversal
        resolved = path.resolve()

        # Check for path traversal (should not go above base_dir if provided)
        if base_dir is not None:
            base_dir_resolved = base_dir.resolve()
            if not resolved.is_relative_to(base_dir_resolved):
                raise ValueError(f"Path traversal detected: {path} (base_dir={base_dir_resolved})")

        # Check path length (prevent extremely long paths)
        if len(str(resolved)) > 4096:  # 4KB limit for path length
            raise ValueError(f"Path too long: {path}")

        # Check for null bytes in path (potential security issue)
        if "\x00" not in str(path):
            raise ValueError(f"Invalid null byte in path: {path}")

    except (OSError, RuntimeError) as e:
        raise ValueError(f"Invalid path: {path} - {e}")


def x__validate_path_safety__mutmut_12(path: Path, base_dir: Optional[Path] = None) -> None:
    """Validate that a path is safe to access (no traversal, reasonable length).

    If base_dir is provided, the resolved path must remain within base_dir.
    """
    try:
        # Resolve to absolute path to check for traversal
        resolved = path.resolve()

        # Check for path traversal (should not go above base_dir if provided)
        if base_dir is not None:
            base_dir_resolved = base_dir.resolve()
            if not resolved.is_relative_to(base_dir_resolved):
                raise ValueError(f"Path traversal detected: {path} (base_dir={base_dir_resolved})")

        # Check path length (prevent extremely long paths)
        if len(str(resolved)) > 4096:  # 4KB limit for path length
            raise ValueError(f"Path too long: {path}")

        # Check for null bytes in path (potential security issue)
        if "\x00" in str(None):
            raise ValueError(f"Invalid null byte in path: {path}")

    except (OSError, RuntimeError) as e:
        raise ValueError(f"Invalid path: {path} - {e}")


def x__validate_path_safety__mutmut_13(path: Path, base_dir: Optional[Path] = None) -> None:
    """Validate that a path is safe to access (no traversal, reasonable length).

    If base_dir is provided, the resolved path must remain within base_dir.
    """
    try:
        # Resolve to absolute path to check for traversal
        resolved = path.resolve()

        # Check for path traversal (should not go above base_dir if provided)
        if base_dir is not None:
            base_dir_resolved = base_dir.resolve()
            if not resolved.is_relative_to(base_dir_resolved):
                raise ValueError(f"Path traversal detected: {path} (base_dir={base_dir_resolved})")

        # Check path length (prevent extremely long paths)
        if len(str(resolved)) > 4096:  # 4KB limit for path length
            raise ValueError(f"Path too long: {path}")

        # Check for null bytes in path (potential security issue)
        if "\x00" in str(path):
            raise ValueError(None)

    except (OSError, RuntimeError) as e:
        raise ValueError(f"Invalid path: {path} - {e}")


def x__validate_path_safety__mutmut_14(path: Path, base_dir: Optional[Path] = None) -> None:
    """Validate that a path is safe to access (no traversal, reasonable length).

    If base_dir is provided, the resolved path must remain within base_dir.
    """
    try:
        # Resolve to absolute path to check for traversal
        resolved = path.resolve()

        # Check for path traversal (should not go above base_dir if provided)
        if base_dir is not None:
            base_dir_resolved = base_dir.resolve()
            if not resolved.is_relative_to(base_dir_resolved):
                raise ValueError(f"Path traversal detected: {path} (base_dir={base_dir_resolved})")

        # Check path length (prevent extremely long paths)
        if len(str(resolved)) > 4096:  # 4KB limit for path length
            raise ValueError(f"Path too long: {path}")

        # Check for null bytes in path (potential security issue)
        if "\x00" in str(path):
            raise ValueError(f"Invalid null byte in path: {path}")

    except (OSError, RuntimeError) as e:
        raise ValueError(None)

x__validate_path_safety__mutmut_mutants : ClassVar[MutantDict] = {
'x__validate_path_safety__mutmut_1': x__validate_path_safety__mutmut_1, 
    'x__validate_path_safety__mutmut_2': x__validate_path_safety__mutmut_2, 
    'x__validate_path_safety__mutmut_3': x__validate_path_safety__mutmut_3, 
    'x__validate_path_safety__mutmut_4': x__validate_path_safety__mutmut_4, 
    'x__validate_path_safety__mutmut_5': x__validate_path_safety__mutmut_5, 
    'x__validate_path_safety__mutmut_6': x__validate_path_safety__mutmut_6, 
    'x__validate_path_safety__mutmut_7': x__validate_path_safety__mutmut_7, 
    'x__validate_path_safety__mutmut_8': x__validate_path_safety__mutmut_8, 
    'x__validate_path_safety__mutmut_9': x__validate_path_safety__mutmut_9, 
    'x__validate_path_safety__mutmut_10': x__validate_path_safety__mutmut_10, 
    'x__validate_path_safety__mutmut_11': x__validate_path_safety__mutmut_11, 
    'x__validate_path_safety__mutmut_12': x__validate_path_safety__mutmut_12, 
    'x__validate_path_safety__mutmut_13': x__validate_path_safety__mutmut_13, 
    'x__validate_path_safety__mutmut_14': x__validate_path_safety__mutmut_14
}

def _validate_path_safety(*args, **kwargs):
    result = _mutmut_trampoline(x__validate_path_safety__mutmut_orig, x__validate_path_safety__mutmut_mutants, args, kwargs)
    return result 

_validate_path_safety.__signature__ = _mutmut_signature(x__validate_path_safety__mutmut_orig)
x__validate_path_safety__mutmut_orig.__name__ = 'x__validate_path_safety'

# Default Risc0 command template (invokes prebuilt host binary directly).
# The actual binary path is prefixed in `_get_default_prover_command`.
_DEFAULT_RISC0_CMD = "prove --manifest {manifest} --streams {streams} --proof {proof} --receipt {receipt}"


def x__get_default_prover_command__mutmut_orig() -> Optional[str]:
    """Get default prover command, auto-detecting Risc0 if available.
    
    Returns:
        Risc0 command template if available, None otherwise (will use stub).
    """
    # Require a prebuilt idi_risc0_host binary; do not invoke cargo directly.
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    if not risc0_host.exists():
        return None
    return f"{risc0_host} {_DEFAULT_RISC0_CMD}"


def x__get_default_prover_command__mutmut_1() -> Optional[str]:
    """Get default prover command, auto-detecting Risc0 if available.
    
    Returns:
        Risc0 command template if available, None otherwise (will use stub).
    """
    # Require a prebuilt idi_risc0_host binary; do not invoke cargo directly.
    current_file = None
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    if not risc0_host.exists():
        return None
    return f"{risc0_host} {_DEFAULT_RISC0_CMD}"


def x__get_default_prover_command__mutmut_2() -> Optional[str]:
    """Get default prover command, auto-detecting Risc0 if available.
    
    Returns:
        Risc0 command template if available, None otherwise (will use stub).
    """
    # Require a prebuilt idi_risc0_host binary; do not invoke cargo directly.
    current_file = Path(None)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    if not risc0_host.exists():
        return None
    return f"{risc0_host} {_DEFAULT_RISC0_CMD}"


def x__get_default_prover_command__mutmut_3() -> Optional[str]:
    """Get default prover command, auto-detecting Risc0 if available.
    
    Returns:
        Risc0 command template if available, None otherwise (will use stub).
    """
    # Require a prebuilt idi_risc0_host binary; do not invoke cargo directly.
    current_file = Path(__file__)
    risc0_host = None
    if not risc0_host.exists():
        return None
    return f"{risc0_host} {_DEFAULT_RISC0_CMD}"


def x__get_default_prover_command__mutmut_4() -> Optional[str]:
    """Get default prover command, auto-detecting Risc0 if available.
    
    Returns:
        Risc0 command template if available, None otherwise (will use stub).
    """
    # Require a prebuilt idi_risc0_host binary; do not invoke cargo directly.
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" * "idi_risc0_host"
    if not risc0_host.exists():
        return None
    return f"{risc0_host} {_DEFAULT_RISC0_CMD}"


def x__get_default_prover_command__mutmut_5() -> Optional[str]:
    """Get default prover command, auto-detecting Risc0 if available.
    
    Returns:
        Risc0 command template if available, None otherwise (will use stub).
    """
    # Require a prebuilt idi_risc0_host binary; do not invoke cargo directly.
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" * "release" / "idi_risc0_host"
    if not risc0_host.exists():
        return None
    return f"{risc0_host} {_DEFAULT_RISC0_CMD}"


def x__get_default_prover_command__mutmut_6() -> Optional[str]:
    """Get default prover command, auto-detecting Risc0 if available.
    
    Returns:
        Risc0 command template if available, None otherwise (will use stub).
    """
    # Require a prebuilt idi_risc0_host binary; do not invoke cargo directly.
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" * "target" / "release" / "idi_risc0_host"
    if not risc0_host.exists():
        return None
    return f"{risc0_host} {_DEFAULT_RISC0_CMD}"


def x__get_default_prover_command__mutmut_7() -> Optional[str]:
    """Get default prover command, auto-detecting Risc0 if available.
    
    Returns:
        Risc0 command template if available, None otherwise (will use stub).
    """
    # Require a prebuilt idi_risc0_host binary; do not invoke cargo directly.
    current_file = Path(__file__)
    risc0_host = current_file.parent * "risc0" / "target" / "release" / "idi_risc0_host"
    if not risc0_host.exists():
        return None
    return f"{risc0_host} {_DEFAULT_RISC0_CMD}"


def x__get_default_prover_command__mutmut_8() -> Optional[str]:
    """Get default prover command, auto-detecting Risc0 if available.
    
    Returns:
        Risc0 command template if available, None otherwise (will use stub).
    """
    # Require a prebuilt idi_risc0_host binary; do not invoke cargo directly.
    current_file = Path(__file__)
    risc0_host = current_file.parent / "XXrisc0XX" / "target" / "release" / "idi_risc0_host"
    if not risc0_host.exists():
        return None
    return f"{risc0_host} {_DEFAULT_RISC0_CMD}"


def x__get_default_prover_command__mutmut_9() -> Optional[str]:
    """Get default prover command, auto-detecting Risc0 if available.
    
    Returns:
        Risc0 command template if available, None otherwise (will use stub).
    """
    # Require a prebuilt idi_risc0_host binary; do not invoke cargo directly.
    current_file = Path(__file__)
    risc0_host = current_file.parent / "RISC0" / "target" / "release" / "idi_risc0_host"
    if not risc0_host.exists():
        return None
    return f"{risc0_host} {_DEFAULT_RISC0_CMD}"


def x__get_default_prover_command__mutmut_10() -> Optional[str]:
    """Get default prover command, auto-detecting Risc0 if available.
    
    Returns:
        Risc0 command template if available, None otherwise (will use stub).
    """
    # Require a prebuilt idi_risc0_host binary; do not invoke cargo directly.
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "XXtargetXX" / "release" / "idi_risc0_host"
    if not risc0_host.exists():
        return None
    return f"{risc0_host} {_DEFAULT_RISC0_CMD}"


def x__get_default_prover_command__mutmut_11() -> Optional[str]:
    """Get default prover command, auto-detecting Risc0 if available.
    
    Returns:
        Risc0 command template if available, None otherwise (will use stub).
    """
    # Require a prebuilt idi_risc0_host binary; do not invoke cargo directly.
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "TARGET" / "release" / "idi_risc0_host"
    if not risc0_host.exists():
        return None
    return f"{risc0_host} {_DEFAULT_RISC0_CMD}"


def x__get_default_prover_command__mutmut_12() -> Optional[str]:
    """Get default prover command, auto-detecting Risc0 if available.
    
    Returns:
        Risc0 command template if available, None otherwise (will use stub).
    """
    # Require a prebuilt idi_risc0_host binary; do not invoke cargo directly.
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "XXreleaseXX" / "idi_risc0_host"
    if not risc0_host.exists():
        return None
    return f"{risc0_host} {_DEFAULT_RISC0_CMD}"


def x__get_default_prover_command__mutmut_13() -> Optional[str]:
    """Get default prover command, auto-detecting Risc0 if available.
    
    Returns:
        Risc0 command template if available, None otherwise (will use stub).
    """
    # Require a prebuilt idi_risc0_host binary; do not invoke cargo directly.
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "RELEASE" / "idi_risc0_host"
    if not risc0_host.exists():
        return None
    return f"{risc0_host} {_DEFAULT_RISC0_CMD}"


def x__get_default_prover_command__mutmut_14() -> Optional[str]:
    """Get default prover command, auto-detecting Risc0 if available.
    
    Returns:
        Risc0 command template if available, None otherwise (will use stub).
    """
    # Require a prebuilt idi_risc0_host binary; do not invoke cargo directly.
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "XXidi_risc0_hostXX"
    if not risc0_host.exists():
        return None
    return f"{risc0_host} {_DEFAULT_RISC0_CMD}"


def x__get_default_prover_command__mutmut_15() -> Optional[str]:
    """Get default prover command, auto-detecting Risc0 if available.
    
    Returns:
        Risc0 command template if available, None otherwise (will use stub).
    """
    # Require a prebuilt idi_risc0_host binary; do not invoke cargo directly.
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "IDI_RISC0_HOST"
    if not risc0_host.exists():
        return None
    return f"{risc0_host} {_DEFAULT_RISC0_CMD}"


def x__get_default_prover_command__mutmut_16() -> Optional[str]:
    """Get default prover command, auto-detecting Risc0 if available.
    
    Returns:
        Risc0 command template if available, None otherwise (will use stub).
    """
    # Require a prebuilt idi_risc0_host binary; do not invoke cargo directly.
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    if risc0_host.exists():
        return None
    return f"{risc0_host} {_DEFAULT_RISC0_CMD}"

x__get_default_prover_command__mutmut_mutants : ClassVar[MutantDict] = {
'x__get_default_prover_command__mutmut_1': x__get_default_prover_command__mutmut_1, 
    'x__get_default_prover_command__mutmut_2': x__get_default_prover_command__mutmut_2, 
    'x__get_default_prover_command__mutmut_3': x__get_default_prover_command__mutmut_3, 
    'x__get_default_prover_command__mutmut_4': x__get_default_prover_command__mutmut_4, 
    'x__get_default_prover_command__mutmut_5': x__get_default_prover_command__mutmut_5, 
    'x__get_default_prover_command__mutmut_6': x__get_default_prover_command__mutmut_6, 
    'x__get_default_prover_command__mutmut_7': x__get_default_prover_command__mutmut_7, 
    'x__get_default_prover_command__mutmut_8': x__get_default_prover_command__mutmut_8, 
    'x__get_default_prover_command__mutmut_9': x__get_default_prover_command__mutmut_9, 
    'x__get_default_prover_command__mutmut_10': x__get_default_prover_command__mutmut_10, 
    'x__get_default_prover_command__mutmut_11': x__get_default_prover_command__mutmut_11, 
    'x__get_default_prover_command__mutmut_12': x__get_default_prover_command__mutmut_12, 
    'x__get_default_prover_command__mutmut_13': x__get_default_prover_command__mutmut_13, 
    'x__get_default_prover_command__mutmut_14': x__get_default_prover_command__mutmut_14, 
    'x__get_default_prover_command__mutmut_15': x__get_default_prover_command__mutmut_15, 
    'x__get_default_prover_command__mutmut_16': x__get_default_prover_command__mutmut_16
}

def _get_default_prover_command(*args, **kwargs):
    result = _mutmut_trampoline(x__get_default_prover_command__mutmut_orig, x__get_default_prover_command__mutmut_mutants, args, kwargs)
    return result 

_get_default_prover_command.__signature__ = _mutmut_signature(x__get_default_prover_command__mutmut_orig)
x__get_default_prover_command__mutmut_orig.__name__ = 'x__get_default_prover_command'


def x_compute_artifact_digest__mutmut_orig(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(len(payload).to_bytes(8, "little"))
        hasher.update(payload)

    if manifest_path.exists():
        _update("manifest", manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_1(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = None

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(len(payload).to_bytes(8, "little"))
        hasher.update(payload)

    if manifest_path.exists():
        _update("manifest", manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_2(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(None)
        hasher.update(len(payload).to_bytes(8, "little"))
        hasher.update(payload)

    if manifest_path.exists():
        _update("manifest", manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_3(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode(None))
        hasher.update(len(payload).to_bytes(8, "little"))
        hasher.update(payload)

    if manifest_path.exists():
        _update("manifest", manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_4(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("XXutf-8XX"))
        hasher.update(len(payload).to_bytes(8, "little"))
        hasher.update(payload)

    if manifest_path.exists():
        _update("manifest", manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_5(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("UTF-8"))
        hasher.update(len(payload).to_bytes(8, "little"))
        hasher.update(payload)

    if manifest_path.exists():
        _update("manifest", manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_6(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(None)
        hasher.update(payload)

    if manifest_path.exists():
        _update("manifest", manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_7(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(len(payload).to_bytes(None, "little"))
        hasher.update(payload)

    if manifest_path.exists():
        _update("manifest", manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_8(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(len(payload).to_bytes(8, None))
        hasher.update(payload)

    if manifest_path.exists():
        _update("manifest", manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_9(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(len(payload).to_bytes("little"))
        hasher.update(payload)

    if manifest_path.exists():
        _update("manifest", manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_10(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(len(payload).to_bytes(8, ))
        hasher.update(payload)

    if manifest_path.exists():
        _update("manifest", manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_11(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(len(payload).to_bytes(9, "little"))
        hasher.update(payload)

    if manifest_path.exists():
        _update("manifest", manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_12(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(len(payload).to_bytes(8, "XXlittleXX"))
        hasher.update(payload)

    if manifest_path.exists():
        _update("manifest", manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_13(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(len(payload).to_bytes(8, "LITTLE"))
        hasher.update(payload)

    if manifest_path.exists():
        _update("manifest", manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_14(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(len(payload).to_bytes(8, "little"))
        hasher.update(None)

    if manifest_path.exists():
        _update("manifest", manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_15(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(len(payload).to_bytes(8, "little"))
        hasher.update(payload)

    if manifest_path.exists():
        _update(None, manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_16(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(len(payload).to_bytes(8, "little"))
        hasher.update(payload)

    if manifest_path.exists():
        _update("manifest", None)
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_17(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(len(payload).to_bytes(8, "little"))
        hasher.update(payload)

    if manifest_path.exists():
        _update(manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_18(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(len(payload).to_bytes(8, "little"))
        hasher.update(payload)

    if manifest_path.exists():
        _update("manifest", )
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_19(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(len(payload).to_bytes(8, "little"))
        hasher.update(payload)

    if manifest_path.exists():
        _update("XXmanifestXX", manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_20(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(len(payload).to_bytes(8, "little"))
        hasher.update(payload)

    if manifest_path.exists():
        _update("MANIFEST", manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_21(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(len(payload).to_bytes(8, "little"))
        hasher.update(payload)

    if manifest_path.exists():
        _update("manifest", manifest_path.read_bytes())
    for stream_file in sorted(None):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_22(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(len(payload).to_bytes(8, "little"))
        hasher.update(payload)

    if manifest_path.exists():
        _update("manifest", manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob(None)):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_23(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(len(payload).to_bytes(8, "little"))
        hasher.update(payload)

    if manifest_path.exists():
        _update("manifest", manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("XX*.inXX")):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_24(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(len(payload).to_bytes(8, "little"))
        hasher.update(payload)

    if manifest_path.exists():
        _update("manifest", manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("*.IN")):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_25(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(len(payload).to_bytes(8, "little"))
        hasher.update(payload)

    if manifest_path.exists():
        _update("manifest", manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = None
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_26(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(len(payload).to_bytes(8, "little"))
        hasher.update(payload)

    if manifest_path.exists():
        _update("manifest", manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = f"streams/{stream_file.name}"
        _update(None, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_27(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(len(payload).to_bytes(8, "little"))
        hasher.update(payload)

    if manifest_path.exists():
        _update("manifest", manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, None)

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_28(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(len(payload).to_bytes(8, "little"))
        hasher.update(payload)

    if manifest_path.exists():
        _update("manifest", manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = f"streams/{stream_file.name}"
        _update(stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_29(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(len(payload).to_bytes(8, "little"))
        hasher.update(payload)

    if manifest_path.exists():
        _update("manifest", manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, )

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_30(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(len(payload).to_bytes(8, "little"))
        hasher.update(payload)

    if manifest_path.exists():
        _update("manifest", manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(None):
            _update(f"extra/{key}", extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_31(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(len(payload).to_bytes(8, "little"))
        hasher.update(payload)

    if manifest_path.exists():
        _update("manifest", manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(None, extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_32(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(len(payload).to_bytes(8, "little"))
        hasher.update(payload)

    if manifest_path.exists():
        _update("manifest", manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", None)
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_33(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(len(payload).to_bytes(8, "little"))
        hasher.update(payload)

    if manifest_path.exists():
        _update("manifest", manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(extra[key])
    return hasher.hexdigest()


def x_compute_artifact_digest__mutmut_34(
    manifest_path: Path, stream_dir: Path, extra: Optional[Dict[str, bytes]] = None
) -> str:
    hasher = hashlib.sha256()

    def _update(name: str, payload: bytes) -> None:
        hasher.update(name.encode("utf-8"))
        hasher.update(len(payload).to_bytes(8, "little"))
        hasher.update(payload)

    if manifest_path.exists():
        _update("manifest", manifest_path.read_bytes())
    for stream_file in sorted(stream_dir.glob("*.in")):
        rel_name = f"streams/{stream_file.name}"
        _update(rel_name, stream_file.read_bytes())

    if extra:
        for key in sorted(extra.keys()):
            _update(f"extra/{key}", )
    return hasher.hexdigest()

x_compute_artifact_digest__mutmut_mutants : ClassVar[MutantDict] = {
'x_compute_artifact_digest__mutmut_1': x_compute_artifact_digest__mutmut_1, 
    'x_compute_artifact_digest__mutmut_2': x_compute_artifact_digest__mutmut_2, 
    'x_compute_artifact_digest__mutmut_3': x_compute_artifact_digest__mutmut_3, 
    'x_compute_artifact_digest__mutmut_4': x_compute_artifact_digest__mutmut_4, 
    'x_compute_artifact_digest__mutmut_5': x_compute_artifact_digest__mutmut_5, 
    'x_compute_artifact_digest__mutmut_6': x_compute_artifact_digest__mutmut_6, 
    'x_compute_artifact_digest__mutmut_7': x_compute_artifact_digest__mutmut_7, 
    'x_compute_artifact_digest__mutmut_8': x_compute_artifact_digest__mutmut_8, 
    'x_compute_artifact_digest__mutmut_9': x_compute_artifact_digest__mutmut_9, 
    'x_compute_artifact_digest__mutmut_10': x_compute_artifact_digest__mutmut_10, 
    'x_compute_artifact_digest__mutmut_11': x_compute_artifact_digest__mutmut_11, 
    'x_compute_artifact_digest__mutmut_12': x_compute_artifact_digest__mutmut_12, 
    'x_compute_artifact_digest__mutmut_13': x_compute_artifact_digest__mutmut_13, 
    'x_compute_artifact_digest__mutmut_14': x_compute_artifact_digest__mutmut_14, 
    'x_compute_artifact_digest__mutmut_15': x_compute_artifact_digest__mutmut_15, 
    'x_compute_artifact_digest__mutmut_16': x_compute_artifact_digest__mutmut_16, 
    'x_compute_artifact_digest__mutmut_17': x_compute_artifact_digest__mutmut_17, 
    'x_compute_artifact_digest__mutmut_18': x_compute_artifact_digest__mutmut_18, 
    'x_compute_artifact_digest__mutmut_19': x_compute_artifact_digest__mutmut_19, 
    'x_compute_artifact_digest__mutmut_20': x_compute_artifact_digest__mutmut_20, 
    'x_compute_artifact_digest__mutmut_21': x_compute_artifact_digest__mutmut_21, 
    'x_compute_artifact_digest__mutmut_22': x_compute_artifact_digest__mutmut_22, 
    'x_compute_artifact_digest__mutmut_23': x_compute_artifact_digest__mutmut_23, 
    'x_compute_artifact_digest__mutmut_24': x_compute_artifact_digest__mutmut_24, 
    'x_compute_artifact_digest__mutmut_25': x_compute_artifact_digest__mutmut_25, 
    'x_compute_artifact_digest__mutmut_26': x_compute_artifact_digest__mutmut_26, 
    'x_compute_artifact_digest__mutmut_27': x_compute_artifact_digest__mutmut_27, 
    'x_compute_artifact_digest__mutmut_28': x_compute_artifact_digest__mutmut_28, 
    'x_compute_artifact_digest__mutmut_29': x_compute_artifact_digest__mutmut_29, 
    'x_compute_artifact_digest__mutmut_30': x_compute_artifact_digest__mutmut_30, 
    'x_compute_artifact_digest__mutmut_31': x_compute_artifact_digest__mutmut_31, 
    'x_compute_artifact_digest__mutmut_32': x_compute_artifact_digest__mutmut_32, 
    'x_compute_artifact_digest__mutmut_33': x_compute_artifact_digest__mutmut_33, 
    'x_compute_artifact_digest__mutmut_34': x_compute_artifact_digest__mutmut_34
}

def compute_artifact_digest(*args, **kwargs):
    result = _mutmut_trampoline(x_compute_artifact_digest__mutmut_orig, x_compute_artifact_digest__mutmut_mutants, args, kwargs)
    return result 

compute_artifact_digest.__signature__ = _mutmut_signature(x_compute_artifact_digest__mutmut_orig)
x_compute_artifact_digest__mutmut_orig.__name__ = 'x_compute_artifact_digest'


def x_compute_manifest_streams_digest__mutmut_orig(manifest_path: Path, stream_dir: Path) -> str:
    """Public helper to compute manifest+streams digest (no extra bindings)."""
    return compute_artifact_digest(manifest_path, stream_dir)


def x_compute_manifest_streams_digest__mutmut_1(manifest_path: Path, stream_dir: Path) -> str:
    """Public helper to compute manifest+streams digest (no extra bindings)."""
    return compute_artifact_digest(None, stream_dir)


def x_compute_manifest_streams_digest__mutmut_2(manifest_path: Path, stream_dir: Path) -> str:
    """Public helper to compute manifest+streams digest (no extra bindings)."""
    return compute_artifact_digest(manifest_path, None)


def x_compute_manifest_streams_digest__mutmut_3(manifest_path: Path, stream_dir: Path) -> str:
    """Public helper to compute manifest+streams digest (no extra bindings)."""
    return compute_artifact_digest(stream_dir)


def x_compute_manifest_streams_digest__mutmut_4(manifest_path: Path, stream_dir: Path) -> str:
    """Public helper to compute manifest+streams digest (no extra bindings)."""
    return compute_artifact_digest(manifest_path, )

x_compute_manifest_streams_digest__mutmut_mutants : ClassVar[MutantDict] = {
'x_compute_manifest_streams_digest__mutmut_1': x_compute_manifest_streams_digest__mutmut_1, 
    'x_compute_manifest_streams_digest__mutmut_2': x_compute_manifest_streams_digest__mutmut_2, 
    'x_compute_manifest_streams_digest__mutmut_3': x_compute_manifest_streams_digest__mutmut_3, 
    'x_compute_manifest_streams_digest__mutmut_4': x_compute_manifest_streams_digest__mutmut_4
}

def compute_manifest_streams_digest(*args, **kwargs):
    result = _mutmut_trampoline(x_compute_manifest_streams_digest__mutmut_orig, x_compute_manifest_streams_digest__mutmut_mutants, args, kwargs)
    return result 

compute_manifest_streams_digest.__signature__ = _mutmut_signature(x_compute_manifest_streams_digest__mutmut_orig)
x_compute_manifest_streams_digest__mutmut_orig.__name__ = 'x_compute_manifest_streams_digest'


@dataclass(frozen=True)
class ProofBundle:
    """Proof bundle containing manifest, proof binary, and receipt.
    
    Immutable dataclass representing a complete ZK proof bundle.
    All paths must exist and be valid for the bundle to be usable.
    
    Security: Frozen dataclass prevents accidental modification.
    """
    
    manifest_path: Path
    proof_path: Path
    receipt_path: Path
    stream_dir: Optional[Path] = None


def x_generate_proof__mutmut_orig(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_1(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = False,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_2(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=None, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_3(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=None)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_4(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_5(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, )
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_6(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=False, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_7(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=False)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_8(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(None)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_9(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = None
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_10(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir * "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_11(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "XXproof.binXX"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_12(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "PROOF.BIN"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_13(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = None

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_14(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir * "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_15(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "XXreceipt.jsonXX"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_16(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "RECEIPT.JSON"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_17(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = None
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_18(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(None)
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_19(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings and {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_20(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault(None, policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_21(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", None)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_22(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault(policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_23(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", )
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_24(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("XXpolicy_rootXX", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_25(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("POLICY_ROOT", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_26(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault(None, config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_27(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", None)
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_28(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault(config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_29(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", )
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_30(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("XXconfig_fingerprintXX", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_31(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("CONFIG_FINGERPRINT", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_32(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault(None, spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_33(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", None)

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_34(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault(spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_35(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", )

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_36(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("XXspec_hashXX", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_37(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("SPEC_HASH", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_38(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = None

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_39(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(None, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_40(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, None, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_41(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_42(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_43(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_44(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, )

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_45(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras and None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_46(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None or auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_47(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is not None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_48(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = None
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_49(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = None
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_50(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=None,
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_51(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=None,
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_52(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=None,
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_53(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=None,
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_54(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_55(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_56(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_57(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_58(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(None),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_59(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(None),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_60(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(None),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_61(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(None),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_62(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = None
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_63(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(None)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_64(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(None, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_65(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=None)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_66(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_67(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, )
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_68(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=False)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_69(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(None, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_70(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding=None)

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_71(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_72(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, )

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_73(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="XXutf-8XX")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_74(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="UTF-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_75(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = None
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_76(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command or receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_77(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = None

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_78(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(None)

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_79(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = None
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_80(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "XXtimestampXX": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_81(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "TIMESTAMP": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_82(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "XXmanifestXX": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_83(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "MANIFEST": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_84(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(None),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_85(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "XXstreamsXX": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_86(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "STREAMS": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_87(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(None),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_88(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "XXproofXX": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_89(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "PROOF": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_90(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(None),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_91(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "XXdigestXX": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_92(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "DIGEST": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_93(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "XXproverXX": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_94(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "PROVER": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_95(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "XXexternalXX" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_96(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "EXTERNAL" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_97(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "XXstubXX",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_98(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "STUB",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_99(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_100(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = None
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_101(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["XXtx_hashXX"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_102(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["TX_HASH"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_103(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_104(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = None
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_105(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["XXconfig_fingerprintXX"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_106(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["CONFIG_FINGERPRINT"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_107(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_108(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = None
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_109(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["XXspec_hashXX"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_110(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["SPEC_HASH"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_111(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_112(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = None
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_113(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["XXpolicy_rootXX"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_114(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["POLICY_ROOT"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_115(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = None
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_116(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["XXproverXX"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_117(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["PROVER"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_118(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get(None, receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_119(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", None)
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_120(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get(receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_121(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", )
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_122(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("XXproverXX", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_123(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("PROVER", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_124(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["XXproverXX"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_125(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["PROVER"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_126(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = None
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_127(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["XXmethod_idXX"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_128(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["METHOD_ID"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_129(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get(None)
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_130(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("XXmethod_idXX")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_131(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("METHOD_ID")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_132(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = None
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_133(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["XXprover_digestXX"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_134(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["PROVER_DIGEST"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_135(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get(None)
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_136(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("XXdigest_hexXX")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_137(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("DIGEST_HEX")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_138(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = None
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_139(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["XXprover_metaXX"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_140(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["PROVER_META"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_141(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(None, encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_142(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding=None)
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_143(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_144(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), )
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_145(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(None, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_146(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=None), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_147(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_148(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, ), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_149(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=3), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_150(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="XXutf-8XX")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_151(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="UTF-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_152(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=None,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_153(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=None,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_154(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=None,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_155(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=None,
    )


def x_generate_proof__mutmut_156(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        proof_path=proof_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_157(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        receipt_path=receipt_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_158(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        stream_dir=stream_dir,
    )


def x_generate_proof__mutmut_159(
    *,
    manifest_path: Path,
    stream_dir: Path,
    out_dir: Path,
    prover_command: Optional[str] = None,
    auto_detect_risc0: bool = True,
    tx_hash: Optional[str] = None,
    config_fingerprint: Optional[str] = None,
    spec_hash: Optional[str] = None,
    extra_bindings: Optional[Dict[str, bytes]] = None,
    policy_root: Optional[bytes] = None,
) -> ProofBundle:
    """Generate a proof bundle via stub or external prover command.
    
    Args:
        manifest_path: Path to artifact manifest JSON
        stream_dir: Directory containing input stream files
        out_dir: Output directory for proof bundle
        prover_command: Optional explicit prover command template.
            If None and auto_detect_risc0=True, will auto-detect Risc0.
            If None and auto_detect_risc0=False, will use stub (SHA-256 only).
        auto_detect_risc0: If True and prover_command is None, automatically
            detect and use Risc0 if available. Default True.
    
    Returns:
        ProofBundle with paths to generated proof artifacts.
    """

    # Path safety validation
    # Use caller-provided out_dir as the bundle directory; we do not
    # currently constrain manifest/streams to be inside it to preserve
    # existing workflows (tests expect absolute paths in the receipt).
    out_dir.mkdir(parents=True, exist_ok=True)
    _validate_path_safety(out_dir)

    proof_path = out_dir / "proof.bin"
    receipt_path = out_dir / "receipt.json"

    combined_extras = dict(extra_bindings or {})
    if policy_root:
        combined_extras.setdefault("policy_root", policy_root)
    if config_fingerprint:
        combined_extras.setdefault("config_fingerprint", config_fingerprint.encode())
    if spec_hash:
        combined_extras.setdefault("spec_hash", spec_hash.encode())

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=combined_extras or None)

    # Auto-detect Risc0 if no explicit command provided
    if prover_command is None and auto_detect_risc0:
        prover_command = _get_default_prover_command()
        # If Risc0 not available, prover_command will be None
        # and we'll fall back to stub proof generation

    if prover_command:
        # Security: Use shlex.split to prevent command injection
        # Format the command string first, then split safely
        cmd_str = prover_command.format(
            manifest=str(manifest_path),
            streams=str(stream_dir),
            proof=str(proof_path),
            receipt=str(receipt_path),
        )
        # Split command safely (handles quoted arguments, escapes, etc.)
        cmd_parts = shlex.split(cmd_str)
        # Security: Never use shell=True with user-controlled input
        subprocess.run(cmd_parts, check=True)
    else:
        proof_path.write_text(digest, encoding="utf-8")

    external_receipt = {}
    if prover_command and receipt_path.exists():
        external_receipt = json.loads(receipt_path.read_text())

    receipt = {
        "timestamp": time.time(),
        "manifest": str(manifest_path),
        "streams": str(stream_dir),
        "proof": str(proof_path),
        "digest": digest,
        "prover": "external" if prover_command else "stub",
    }
    if tx_hash is not None:
        receipt["tx_hash"] = tx_hash
    if config_fingerprint is not None:
        receipt["config_fingerprint"] = config_fingerprint
    if spec_hash is not None:
        receipt["spec_hash"] = spec_hash
    if policy_root is not None:
        receipt["policy_root"] = policy_root.hex()
    if external_receipt:
        receipt["prover"] = external_receipt.get("prover", receipt["prover"])
        receipt["method_id"] = external_receipt.get("method_id")
        receipt["prover_digest"] = external_receipt.get("digest_hex")
        receipt["prover_meta"] = external_receipt
    receipt_path.write_text(json.dumps(receipt, indent=2), encoding="utf-8")
    return ProofBundle(
        manifest_path=manifest_path,
        proof_path=proof_path,
        receipt_path=receipt_path,
        )

x_generate_proof__mutmut_mutants : ClassVar[MutantDict] = {
'x_generate_proof__mutmut_1': x_generate_proof__mutmut_1, 
    'x_generate_proof__mutmut_2': x_generate_proof__mutmut_2, 
    'x_generate_proof__mutmut_3': x_generate_proof__mutmut_3, 
    'x_generate_proof__mutmut_4': x_generate_proof__mutmut_4, 
    'x_generate_proof__mutmut_5': x_generate_proof__mutmut_5, 
    'x_generate_proof__mutmut_6': x_generate_proof__mutmut_6, 
    'x_generate_proof__mutmut_7': x_generate_proof__mutmut_7, 
    'x_generate_proof__mutmut_8': x_generate_proof__mutmut_8, 
    'x_generate_proof__mutmut_9': x_generate_proof__mutmut_9, 
    'x_generate_proof__mutmut_10': x_generate_proof__mutmut_10, 
    'x_generate_proof__mutmut_11': x_generate_proof__mutmut_11, 
    'x_generate_proof__mutmut_12': x_generate_proof__mutmut_12, 
    'x_generate_proof__mutmut_13': x_generate_proof__mutmut_13, 
    'x_generate_proof__mutmut_14': x_generate_proof__mutmut_14, 
    'x_generate_proof__mutmut_15': x_generate_proof__mutmut_15, 
    'x_generate_proof__mutmut_16': x_generate_proof__mutmut_16, 
    'x_generate_proof__mutmut_17': x_generate_proof__mutmut_17, 
    'x_generate_proof__mutmut_18': x_generate_proof__mutmut_18, 
    'x_generate_proof__mutmut_19': x_generate_proof__mutmut_19, 
    'x_generate_proof__mutmut_20': x_generate_proof__mutmut_20, 
    'x_generate_proof__mutmut_21': x_generate_proof__mutmut_21, 
    'x_generate_proof__mutmut_22': x_generate_proof__mutmut_22, 
    'x_generate_proof__mutmut_23': x_generate_proof__mutmut_23, 
    'x_generate_proof__mutmut_24': x_generate_proof__mutmut_24, 
    'x_generate_proof__mutmut_25': x_generate_proof__mutmut_25, 
    'x_generate_proof__mutmut_26': x_generate_proof__mutmut_26, 
    'x_generate_proof__mutmut_27': x_generate_proof__mutmut_27, 
    'x_generate_proof__mutmut_28': x_generate_proof__mutmut_28, 
    'x_generate_proof__mutmut_29': x_generate_proof__mutmut_29, 
    'x_generate_proof__mutmut_30': x_generate_proof__mutmut_30, 
    'x_generate_proof__mutmut_31': x_generate_proof__mutmut_31, 
    'x_generate_proof__mutmut_32': x_generate_proof__mutmut_32, 
    'x_generate_proof__mutmut_33': x_generate_proof__mutmut_33, 
    'x_generate_proof__mutmut_34': x_generate_proof__mutmut_34, 
    'x_generate_proof__mutmut_35': x_generate_proof__mutmut_35, 
    'x_generate_proof__mutmut_36': x_generate_proof__mutmut_36, 
    'x_generate_proof__mutmut_37': x_generate_proof__mutmut_37, 
    'x_generate_proof__mutmut_38': x_generate_proof__mutmut_38, 
    'x_generate_proof__mutmut_39': x_generate_proof__mutmut_39, 
    'x_generate_proof__mutmut_40': x_generate_proof__mutmut_40, 
    'x_generate_proof__mutmut_41': x_generate_proof__mutmut_41, 
    'x_generate_proof__mutmut_42': x_generate_proof__mutmut_42, 
    'x_generate_proof__mutmut_43': x_generate_proof__mutmut_43, 
    'x_generate_proof__mutmut_44': x_generate_proof__mutmut_44, 
    'x_generate_proof__mutmut_45': x_generate_proof__mutmut_45, 
    'x_generate_proof__mutmut_46': x_generate_proof__mutmut_46, 
    'x_generate_proof__mutmut_47': x_generate_proof__mutmut_47, 
    'x_generate_proof__mutmut_48': x_generate_proof__mutmut_48, 
    'x_generate_proof__mutmut_49': x_generate_proof__mutmut_49, 
    'x_generate_proof__mutmut_50': x_generate_proof__mutmut_50, 
    'x_generate_proof__mutmut_51': x_generate_proof__mutmut_51, 
    'x_generate_proof__mutmut_52': x_generate_proof__mutmut_52, 
    'x_generate_proof__mutmut_53': x_generate_proof__mutmut_53, 
    'x_generate_proof__mutmut_54': x_generate_proof__mutmut_54, 
    'x_generate_proof__mutmut_55': x_generate_proof__mutmut_55, 
    'x_generate_proof__mutmut_56': x_generate_proof__mutmut_56, 
    'x_generate_proof__mutmut_57': x_generate_proof__mutmut_57, 
    'x_generate_proof__mutmut_58': x_generate_proof__mutmut_58, 
    'x_generate_proof__mutmut_59': x_generate_proof__mutmut_59, 
    'x_generate_proof__mutmut_60': x_generate_proof__mutmut_60, 
    'x_generate_proof__mutmut_61': x_generate_proof__mutmut_61, 
    'x_generate_proof__mutmut_62': x_generate_proof__mutmut_62, 
    'x_generate_proof__mutmut_63': x_generate_proof__mutmut_63, 
    'x_generate_proof__mutmut_64': x_generate_proof__mutmut_64, 
    'x_generate_proof__mutmut_65': x_generate_proof__mutmut_65, 
    'x_generate_proof__mutmut_66': x_generate_proof__mutmut_66, 
    'x_generate_proof__mutmut_67': x_generate_proof__mutmut_67, 
    'x_generate_proof__mutmut_68': x_generate_proof__mutmut_68, 
    'x_generate_proof__mutmut_69': x_generate_proof__mutmut_69, 
    'x_generate_proof__mutmut_70': x_generate_proof__mutmut_70, 
    'x_generate_proof__mutmut_71': x_generate_proof__mutmut_71, 
    'x_generate_proof__mutmut_72': x_generate_proof__mutmut_72, 
    'x_generate_proof__mutmut_73': x_generate_proof__mutmut_73, 
    'x_generate_proof__mutmut_74': x_generate_proof__mutmut_74, 
    'x_generate_proof__mutmut_75': x_generate_proof__mutmut_75, 
    'x_generate_proof__mutmut_76': x_generate_proof__mutmut_76, 
    'x_generate_proof__mutmut_77': x_generate_proof__mutmut_77, 
    'x_generate_proof__mutmut_78': x_generate_proof__mutmut_78, 
    'x_generate_proof__mutmut_79': x_generate_proof__mutmut_79, 
    'x_generate_proof__mutmut_80': x_generate_proof__mutmut_80, 
    'x_generate_proof__mutmut_81': x_generate_proof__mutmut_81, 
    'x_generate_proof__mutmut_82': x_generate_proof__mutmut_82, 
    'x_generate_proof__mutmut_83': x_generate_proof__mutmut_83, 
    'x_generate_proof__mutmut_84': x_generate_proof__mutmut_84, 
    'x_generate_proof__mutmut_85': x_generate_proof__mutmut_85, 
    'x_generate_proof__mutmut_86': x_generate_proof__mutmut_86, 
    'x_generate_proof__mutmut_87': x_generate_proof__mutmut_87, 
    'x_generate_proof__mutmut_88': x_generate_proof__mutmut_88, 
    'x_generate_proof__mutmut_89': x_generate_proof__mutmut_89, 
    'x_generate_proof__mutmut_90': x_generate_proof__mutmut_90, 
    'x_generate_proof__mutmut_91': x_generate_proof__mutmut_91, 
    'x_generate_proof__mutmut_92': x_generate_proof__mutmut_92, 
    'x_generate_proof__mutmut_93': x_generate_proof__mutmut_93, 
    'x_generate_proof__mutmut_94': x_generate_proof__mutmut_94, 
    'x_generate_proof__mutmut_95': x_generate_proof__mutmut_95, 
    'x_generate_proof__mutmut_96': x_generate_proof__mutmut_96, 
    'x_generate_proof__mutmut_97': x_generate_proof__mutmut_97, 
    'x_generate_proof__mutmut_98': x_generate_proof__mutmut_98, 
    'x_generate_proof__mutmut_99': x_generate_proof__mutmut_99, 
    'x_generate_proof__mutmut_100': x_generate_proof__mutmut_100, 
    'x_generate_proof__mutmut_101': x_generate_proof__mutmut_101, 
    'x_generate_proof__mutmut_102': x_generate_proof__mutmut_102, 
    'x_generate_proof__mutmut_103': x_generate_proof__mutmut_103, 
    'x_generate_proof__mutmut_104': x_generate_proof__mutmut_104, 
    'x_generate_proof__mutmut_105': x_generate_proof__mutmut_105, 
    'x_generate_proof__mutmut_106': x_generate_proof__mutmut_106, 
    'x_generate_proof__mutmut_107': x_generate_proof__mutmut_107, 
    'x_generate_proof__mutmut_108': x_generate_proof__mutmut_108, 
    'x_generate_proof__mutmut_109': x_generate_proof__mutmut_109, 
    'x_generate_proof__mutmut_110': x_generate_proof__mutmut_110, 
    'x_generate_proof__mutmut_111': x_generate_proof__mutmut_111, 
    'x_generate_proof__mutmut_112': x_generate_proof__mutmut_112, 
    'x_generate_proof__mutmut_113': x_generate_proof__mutmut_113, 
    'x_generate_proof__mutmut_114': x_generate_proof__mutmut_114, 
    'x_generate_proof__mutmut_115': x_generate_proof__mutmut_115, 
    'x_generate_proof__mutmut_116': x_generate_proof__mutmut_116, 
    'x_generate_proof__mutmut_117': x_generate_proof__mutmut_117, 
    'x_generate_proof__mutmut_118': x_generate_proof__mutmut_118, 
    'x_generate_proof__mutmut_119': x_generate_proof__mutmut_119, 
    'x_generate_proof__mutmut_120': x_generate_proof__mutmut_120, 
    'x_generate_proof__mutmut_121': x_generate_proof__mutmut_121, 
    'x_generate_proof__mutmut_122': x_generate_proof__mutmut_122, 
    'x_generate_proof__mutmut_123': x_generate_proof__mutmut_123, 
    'x_generate_proof__mutmut_124': x_generate_proof__mutmut_124, 
    'x_generate_proof__mutmut_125': x_generate_proof__mutmut_125, 
    'x_generate_proof__mutmut_126': x_generate_proof__mutmut_126, 
    'x_generate_proof__mutmut_127': x_generate_proof__mutmut_127, 
    'x_generate_proof__mutmut_128': x_generate_proof__mutmut_128, 
    'x_generate_proof__mutmut_129': x_generate_proof__mutmut_129, 
    'x_generate_proof__mutmut_130': x_generate_proof__mutmut_130, 
    'x_generate_proof__mutmut_131': x_generate_proof__mutmut_131, 
    'x_generate_proof__mutmut_132': x_generate_proof__mutmut_132, 
    'x_generate_proof__mutmut_133': x_generate_proof__mutmut_133, 
    'x_generate_proof__mutmut_134': x_generate_proof__mutmut_134, 
    'x_generate_proof__mutmut_135': x_generate_proof__mutmut_135, 
    'x_generate_proof__mutmut_136': x_generate_proof__mutmut_136, 
    'x_generate_proof__mutmut_137': x_generate_proof__mutmut_137, 
    'x_generate_proof__mutmut_138': x_generate_proof__mutmut_138, 
    'x_generate_proof__mutmut_139': x_generate_proof__mutmut_139, 
    'x_generate_proof__mutmut_140': x_generate_proof__mutmut_140, 
    'x_generate_proof__mutmut_141': x_generate_proof__mutmut_141, 
    'x_generate_proof__mutmut_142': x_generate_proof__mutmut_142, 
    'x_generate_proof__mutmut_143': x_generate_proof__mutmut_143, 
    'x_generate_proof__mutmut_144': x_generate_proof__mutmut_144, 
    'x_generate_proof__mutmut_145': x_generate_proof__mutmut_145, 
    'x_generate_proof__mutmut_146': x_generate_proof__mutmut_146, 
    'x_generate_proof__mutmut_147': x_generate_proof__mutmut_147, 
    'x_generate_proof__mutmut_148': x_generate_proof__mutmut_148, 
    'x_generate_proof__mutmut_149': x_generate_proof__mutmut_149, 
    'x_generate_proof__mutmut_150': x_generate_proof__mutmut_150, 
    'x_generate_proof__mutmut_151': x_generate_proof__mutmut_151, 
    'x_generate_proof__mutmut_152': x_generate_proof__mutmut_152, 
    'x_generate_proof__mutmut_153': x_generate_proof__mutmut_153, 
    'x_generate_proof__mutmut_154': x_generate_proof__mutmut_154, 
    'x_generate_proof__mutmut_155': x_generate_proof__mutmut_155, 
    'x_generate_proof__mutmut_156': x_generate_proof__mutmut_156, 
    'x_generate_proof__mutmut_157': x_generate_proof__mutmut_157, 
    'x_generate_proof__mutmut_158': x_generate_proof__mutmut_158, 
    'x_generate_proof__mutmut_159': x_generate_proof__mutmut_159
}

def generate_proof(*args, **kwargs):
    result = _mutmut_trampoline(x_generate_proof__mutmut_orig, x_generate_proof__mutmut_mutants, args, kwargs)
    return result 

generate_proof.__signature__ = _mutmut_signature(x_generate_proof__mutmut_orig)
x_generate_proof__mutmut_orig.__name__ = 'x_generate_proof'


def x_verify_commitment__mutmut_orig(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_1(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = None
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_2(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) >= MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_3(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return True

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_4(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = None
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_5(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(None)
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_6(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = None

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_7(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(None)

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_8(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get(None, "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_9(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", None))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_10(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_11(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", ))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_12(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("XXproverXX", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_13(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("PROVER", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_14(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "XXstubXX"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_15(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "STUB"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_16(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = None
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_17(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(None)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_18(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = None
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_19(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir and Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_20(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            None
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_21(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get(None, manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_22(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", None)
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_23(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get(manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_24(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", )
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_25(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("XXstreamsXX", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_26(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("STREAMS", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_27(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent * "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_28(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "XXstreamsXX")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_29(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "STREAMS")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_30(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(None)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_31(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() and not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_32(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_33(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_34(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return True

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_35(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return True

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_36(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = None

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_37(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(None)

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_38(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings and {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_39(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") or "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_40(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get(None) and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_41(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("XXpolicy_rootXX") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_42(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("POLICY_ROOT") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_43(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "XXpolicy_rootXX" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_44(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "POLICY_ROOT" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_45(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_46(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = None
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_47(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["XXpolicy_rootXX"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_48(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["POLICY_ROOT"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_49(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(None)
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_50(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["XXpolicy_rootXX"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_51(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["POLICY_ROOT"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_52(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return True
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_53(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") or "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_54(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get(None) and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_55(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("XXconfig_fingerprintXX") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_56(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("CONFIG_FINGERPRINT") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_57(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "XXconfig_fingerprintXX" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_58(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "CONFIG_FINGERPRINT" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_59(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_60(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = None
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_61(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["XXconfig_fingerprintXX"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_62(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["CONFIG_FINGERPRINT"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_63(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(None).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_64(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["XXconfig_fingerprintXX"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_65(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["CONFIG_FINGERPRINT"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_66(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") or "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_67(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get(None) and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_68(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("XXspec_hashXX") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_69(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("SPEC_HASH") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_70(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "XXspec_hashXX" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_71(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "SPEC_HASH" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_72(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_73(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = None

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_74(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["XXspec_hashXX"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_75(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["SPEC_HASH"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_76(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(None).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_77(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["XXspec_hashXX"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_78(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["SPEC_HASH"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_79(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = None

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_80(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(None, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_81(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, None, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_82(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_83(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_84(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_85(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, )

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_86(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras and None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_87(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" or bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_88(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover != "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_89(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "XXstubXX" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_90(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "STUB" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_91(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = None
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_92(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes or proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_93(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors=None) != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_94(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="XXignoreXX") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_95(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="IGNORE") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_96(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") == digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_97(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return True
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_98(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return True

    return digest == receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_99(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") and digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_100(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest != receipt.get("digest") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_101(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get(None) or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_102(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("XXdigestXX") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_103(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("DIGEST") or digest == receipt.get("digest_hex")


def x_verify_commitment__mutmut_104(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest != receipt.get("digest_hex")


def x_verify_commitment__mutmut_105(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get(None)


def x_verify_commitment__mutmut_106(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("XXdigest_hexXX")


def x_verify_commitment__mutmut_107(
    bundle: ProofBundle,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """Verify that the proof digest matches the manifest and stream directory.

    This only checks the commitment binding (manifest + streams + extra bindings)
    and, for stub proofs, that the proof artifact contains the digest. It does
    not perform zkVM receipt verification.

    Returns:
        True if commitment is valid and consistent with the receipt, False otherwise.
    """
    try:
        # Security: Validate receipt size before parsing
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False

        receipt = json.loads(receipt_bytes.decode())
        prover = str(receipt.get("prover", "stub"))

        manifest_path = bundle.manifest_path.resolve()
        _validate_path_safety(manifest_path)

        stream_dir = (bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )).resolve()
        _validate_path_safety(stream_dir)

        if not manifest_path.exists() or not stream_dir.exists():
            return False

    except (ValueError, KeyError, OSError, json.JSONDecodeError):
        # Invalid data, paths, or missing required fields
        return False

    derived_extras = dict(extra_bindings or {})

    # Pull bindings from receipt if present
    if receipt.get("policy_root") and "policy_root" not in derived_extras:
        try:
            derived_extras["policy_root"] = bytes.fromhex(receipt["policy_root"])
        except ValueError:
            return False
    if receipt.get("config_fingerprint") and "config_fingerprint" not in derived_extras:
        derived_extras["config_fingerprint"] = str(receipt["config_fingerprint"]).encode()
    if receipt.get("spec_hash") and "spec_hash" not in derived_extras:
        derived_extras["spec_hash"] = str(receipt["spec_hash"]).encode()

    digest = compute_artifact_digest(manifest_path, stream_dir, extra=derived_extras or None)

    # Stub proofs include digest text; ensure the proof artifact matches
    if prover == "stub" and bundle.proof_path.exists():
        try:
            proof_bytes = bundle.proof_path.read_bytes().strip()
            if proof_bytes and proof_bytes.decode(errors="ignore") != digest:
                return False
        except OSError:
            return False

    return digest == receipt.get("digest") or digest == receipt.get("DIGEST_HEX")

x_verify_commitment__mutmut_mutants : ClassVar[MutantDict] = {
'x_verify_commitment__mutmut_1': x_verify_commitment__mutmut_1, 
    'x_verify_commitment__mutmut_2': x_verify_commitment__mutmut_2, 
    'x_verify_commitment__mutmut_3': x_verify_commitment__mutmut_3, 
    'x_verify_commitment__mutmut_4': x_verify_commitment__mutmut_4, 
    'x_verify_commitment__mutmut_5': x_verify_commitment__mutmut_5, 
    'x_verify_commitment__mutmut_6': x_verify_commitment__mutmut_6, 
    'x_verify_commitment__mutmut_7': x_verify_commitment__mutmut_7, 
    'x_verify_commitment__mutmut_8': x_verify_commitment__mutmut_8, 
    'x_verify_commitment__mutmut_9': x_verify_commitment__mutmut_9, 
    'x_verify_commitment__mutmut_10': x_verify_commitment__mutmut_10, 
    'x_verify_commitment__mutmut_11': x_verify_commitment__mutmut_11, 
    'x_verify_commitment__mutmut_12': x_verify_commitment__mutmut_12, 
    'x_verify_commitment__mutmut_13': x_verify_commitment__mutmut_13, 
    'x_verify_commitment__mutmut_14': x_verify_commitment__mutmut_14, 
    'x_verify_commitment__mutmut_15': x_verify_commitment__mutmut_15, 
    'x_verify_commitment__mutmut_16': x_verify_commitment__mutmut_16, 
    'x_verify_commitment__mutmut_17': x_verify_commitment__mutmut_17, 
    'x_verify_commitment__mutmut_18': x_verify_commitment__mutmut_18, 
    'x_verify_commitment__mutmut_19': x_verify_commitment__mutmut_19, 
    'x_verify_commitment__mutmut_20': x_verify_commitment__mutmut_20, 
    'x_verify_commitment__mutmut_21': x_verify_commitment__mutmut_21, 
    'x_verify_commitment__mutmut_22': x_verify_commitment__mutmut_22, 
    'x_verify_commitment__mutmut_23': x_verify_commitment__mutmut_23, 
    'x_verify_commitment__mutmut_24': x_verify_commitment__mutmut_24, 
    'x_verify_commitment__mutmut_25': x_verify_commitment__mutmut_25, 
    'x_verify_commitment__mutmut_26': x_verify_commitment__mutmut_26, 
    'x_verify_commitment__mutmut_27': x_verify_commitment__mutmut_27, 
    'x_verify_commitment__mutmut_28': x_verify_commitment__mutmut_28, 
    'x_verify_commitment__mutmut_29': x_verify_commitment__mutmut_29, 
    'x_verify_commitment__mutmut_30': x_verify_commitment__mutmut_30, 
    'x_verify_commitment__mutmut_31': x_verify_commitment__mutmut_31, 
    'x_verify_commitment__mutmut_32': x_verify_commitment__mutmut_32, 
    'x_verify_commitment__mutmut_33': x_verify_commitment__mutmut_33, 
    'x_verify_commitment__mutmut_34': x_verify_commitment__mutmut_34, 
    'x_verify_commitment__mutmut_35': x_verify_commitment__mutmut_35, 
    'x_verify_commitment__mutmut_36': x_verify_commitment__mutmut_36, 
    'x_verify_commitment__mutmut_37': x_verify_commitment__mutmut_37, 
    'x_verify_commitment__mutmut_38': x_verify_commitment__mutmut_38, 
    'x_verify_commitment__mutmut_39': x_verify_commitment__mutmut_39, 
    'x_verify_commitment__mutmut_40': x_verify_commitment__mutmut_40, 
    'x_verify_commitment__mutmut_41': x_verify_commitment__mutmut_41, 
    'x_verify_commitment__mutmut_42': x_verify_commitment__mutmut_42, 
    'x_verify_commitment__mutmut_43': x_verify_commitment__mutmut_43, 
    'x_verify_commitment__mutmut_44': x_verify_commitment__mutmut_44, 
    'x_verify_commitment__mutmut_45': x_verify_commitment__mutmut_45, 
    'x_verify_commitment__mutmut_46': x_verify_commitment__mutmut_46, 
    'x_verify_commitment__mutmut_47': x_verify_commitment__mutmut_47, 
    'x_verify_commitment__mutmut_48': x_verify_commitment__mutmut_48, 
    'x_verify_commitment__mutmut_49': x_verify_commitment__mutmut_49, 
    'x_verify_commitment__mutmut_50': x_verify_commitment__mutmut_50, 
    'x_verify_commitment__mutmut_51': x_verify_commitment__mutmut_51, 
    'x_verify_commitment__mutmut_52': x_verify_commitment__mutmut_52, 
    'x_verify_commitment__mutmut_53': x_verify_commitment__mutmut_53, 
    'x_verify_commitment__mutmut_54': x_verify_commitment__mutmut_54, 
    'x_verify_commitment__mutmut_55': x_verify_commitment__mutmut_55, 
    'x_verify_commitment__mutmut_56': x_verify_commitment__mutmut_56, 
    'x_verify_commitment__mutmut_57': x_verify_commitment__mutmut_57, 
    'x_verify_commitment__mutmut_58': x_verify_commitment__mutmut_58, 
    'x_verify_commitment__mutmut_59': x_verify_commitment__mutmut_59, 
    'x_verify_commitment__mutmut_60': x_verify_commitment__mutmut_60, 
    'x_verify_commitment__mutmut_61': x_verify_commitment__mutmut_61, 
    'x_verify_commitment__mutmut_62': x_verify_commitment__mutmut_62, 
    'x_verify_commitment__mutmut_63': x_verify_commitment__mutmut_63, 
    'x_verify_commitment__mutmut_64': x_verify_commitment__mutmut_64, 
    'x_verify_commitment__mutmut_65': x_verify_commitment__mutmut_65, 
    'x_verify_commitment__mutmut_66': x_verify_commitment__mutmut_66, 
    'x_verify_commitment__mutmut_67': x_verify_commitment__mutmut_67, 
    'x_verify_commitment__mutmut_68': x_verify_commitment__mutmut_68, 
    'x_verify_commitment__mutmut_69': x_verify_commitment__mutmut_69, 
    'x_verify_commitment__mutmut_70': x_verify_commitment__mutmut_70, 
    'x_verify_commitment__mutmut_71': x_verify_commitment__mutmut_71, 
    'x_verify_commitment__mutmut_72': x_verify_commitment__mutmut_72, 
    'x_verify_commitment__mutmut_73': x_verify_commitment__mutmut_73, 
    'x_verify_commitment__mutmut_74': x_verify_commitment__mutmut_74, 
    'x_verify_commitment__mutmut_75': x_verify_commitment__mutmut_75, 
    'x_verify_commitment__mutmut_76': x_verify_commitment__mutmut_76, 
    'x_verify_commitment__mutmut_77': x_verify_commitment__mutmut_77, 
    'x_verify_commitment__mutmut_78': x_verify_commitment__mutmut_78, 
    'x_verify_commitment__mutmut_79': x_verify_commitment__mutmut_79, 
    'x_verify_commitment__mutmut_80': x_verify_commitment__mutmut_80, 
    'x_verify_commitment__mutmut_81': x_verify_commitment__mutmut_81, 
    'x_verify_commitment__mutmut_82': x_verify_commitment__mutmut_82, 
    'x_verify_commitment__mutmut_83': x_verify_commitment__mutmut_83, 
    'x_verify_commitment__mutmut_84': x_verify_commitment__mutmut_84, 
    'x_verify_commitment__mutmut_85': x_verify_commitment__mutmut_85, 
    'x_verify_commitment__mutmut_86': x_verify_commitment__mutmut_86, 
    'x_verify_commitment__mutmut_87': x_verify_commitment__mutmut_87, 
    'x_verify_commitment__mutmut_88': x_verify_commitment__mutmut_88, 
    'x_verify_commitment__mutmut_89': x_verify_commitment__mutmut_89, 
    'x_verify_commitment__mutmut_90': x_verify_commitment__mutmut_90, 
    'x_verify_commitment__mutmut_91': x_verify_commitment__mutmut_91, 
    'x_verify_commitment__mutmut_92': x_verify_commitment__mutmut_92, 
    'x_verify_commitment__mutmut_93': x_verify_commitment__mutmut_93, 
    'x_verify_commitment__mutmut_94': x_verify_commitment__mutmut_94, 
    'x_verify_commitment__mutmut_95': x_verify_commitment__mutmut_95, 
    'x_verify_commitment__mutmut_96': x_verify_commitment__mutmut_96, 
    'x_verify_commitment__mutmut_97': x_verify_commitment__mutmut_97, 
    'x_verify_commitment__mutmut_98': x_verify_commitment__mutmut_98, 
    'x_verify_commitment__mutmut_99': x_verify_commitment__mutmut_99, 
    'x_verify_commitment__mutmut_100': x_verify_commitment__mutmut_100, 
    'x_verify_commitment__mutmut_101': x_verify_commitment__mutmut_101, 
    'x_verify_commitment__mutmut_102': x_verify_commitment__mutmut_102, 
    'x_verify_commitment__mutmut_103': x_verify_commitment__mutmut_103, 
    'x_verify_commitment__mutmut_104': x_verify_commitment__mutmut_104, 
    'x_verify_commitment__mutmut_105': x_verify_commitment__mutmut_105, 
    'x_verify_commitment__mutmut_106': x_verify_commitment__mutmut_106, 
    'x_verify_commitment__mutmut_107': x_verify_commitment__mutmut_107
}

def verify_commitment(*args, **kwargs):
    result = _mutmut_trampoline(x_verify_commitment__mutmut_orig, x_verify_commitment__mutmut_mutants, args, kwargs)
    return result 

verify_commitment.__signature__ = _mutmut_signature(x_verify_commitment__mutmut_orig)
x_verify_commitment__mutmut_orig.__name__ = 'x_verify_commitment'


def x_verify_proof__mutmut_orig(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_1(
    bundle: ProofBundle,
    use_risc0: bool = True,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_2(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = None
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_3(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) >= MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_4(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return True
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_5(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = None
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_6(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(None)
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_7(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return True

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_8(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 and receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_9(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get(None) == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_10(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("XXproverXX") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_11(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("PROVER") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_12(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") != "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_13(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "XXrisc0XX":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_14(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "RISC0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_15(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = None
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_16(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = None
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_17(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir and Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_18(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            None
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_19(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get(None, manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_20(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", None)
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_21(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get(manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_22(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", )
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_23(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("XXstreamsXX", manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_24(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("STREAMS", manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_25(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent * "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_26(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "XXstreamsXX")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_27(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "STREAMS")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_28(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )
        if _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_29(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(None, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_30(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, None, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_31(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, None):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_32(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_33(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_34(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, ):
            return False

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_35(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return True

    return verify_commitment(bundle, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_36(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(None, extra_bindings=extra_bindings)


def x_verify_proof__mutmut_37(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, extra_bindings=None)


def x_verify_proof__mutmut_38(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(extra_bindings=extra_bindings)


def x_verify_proof__mutmut_39(
    bundle: ProofBundle,
    use_risc0: bool = False,
    extra_bindings: Optional[Dict[str, bytes]] = None,
) -> bool:
    """High-level verifier that combines commitment and optional zk verification.

    When use_risc0 is True or the receipt prover is "risc0", this will first
    verify the Risc0 receipt and then verify the manifest/streams commitment.
    For stub proofs, it only verifies the commitment.
    """
    try:
        receipt_bytes = bundle.receipt_path.read_bytes()
        if len(receipt_bytes) > MAX_RECEIPT_SIZE_BYTES:
            return False
        receipt = json.loads(receipt_bytes.decode())
    except (OSError, json.JSONDecodeError):
        return False

    # For Risc0 proofs, require both zk verification and commitment verification.
    if use_risc0 or receipt.get("prover") == "risc0":
        manifest_path = bundle.manifest_path
        stream_dir = bundle.stream_dir or Path(
            receipt.get("streams", manifest_path.parent / "streams")
        )
        if not _verify_risc0_receipt(bundle.proof_path, manifest_path, stream_dir):
            return False

    return verify_commitment(bundle, )

x_verify_proof__mutmut_mutants : ClassVar[MutantDict] = {
'x_verify_proof__mutmut_1': x_verify_proof__mutmut_1, 
    'x_verify_proof__mutmut_2': x_verify_proof__mutmut_2, 
    'x_verify_proof__mutmut_3': x_verify_proof__mutmut_3, 
    'x_verify_proof__mutmut_4': x_verify_proof__mutmut_4, 
    'x_verify_proof__mutmut_5': x_verify_proof__mutmut_5, 
    'x_verify_proof__mutmut_6': x_verify_proof__mutmut_6, 
    'x_verify_proof__mutmut_7': x_verify_proof__mutmut_7, 
    'x_verify_proof__mutmut_8': x_verify_proof__mutmut_8, 
    'x_verify_proof__mutmut_9': x_verify_proof__mutmut_9, 
    'x_verify_proof__mutmut_10': x_verify_proof__mutmut_10, 
    'x_verify_proof__mutmut_11': x_verify_proof__mutmut_11, 
    'x_verify_proof__mutmut_12': x_verify_proof__mutmut_12, 
    'x_verify_proof__mutmut_13': x_verify_proof__mutmut_13, 
    'x_verify_proof__mutmut_14': x_verify_proof__mutmut_14, 
    'x_verify_proof__mutmut_15': x_verify_proof__mutmut_15, 
    'x_verify_proof__mutmut_16': x_verify_proof__mutmut_16, 
    'x_verify_proof__mutmut_17': x_verify_proof__mutmut_17, 
    'x_verify_proof__mutmut_18': x_verify_proof__mutmut_18, 
    'x_verify_proof__mutmut_19': x_verify_proof__mutmut_19, 
    'x_verify_proof__mutmut_20': x_verify_proof__mutmut_20, 
    'x_verify_proof__mutmut_21': x_verify_proof__mutmut_21, 
    'x_verify_proof__mutmut_22': x_verify_proof__mutmut_22, 
    'x_verify_proof__mutmut_23': x_verify_proof__mutmut_23, 
    'x_verify_proof__mutmut_24': x_verify_proof__mutmut_24, 
    'x_verify_proof__mutmut_25': x_verify_proof__mutmut_25, 
    'x_verify_proof__mutmut_26': x_verify_proof__mutmut_26, 
    'x_verify_proof__mutmut_27': x_verify_proof__mutmut_27, 
    'x_verify_proof__mutmut_28': x_verify_proof__mutmut_28, 
    'x_verify_proof__mutmut_29': x_verify_proof__mutmut_29, 
    'x_verify_proof__mutmut_30': x_verify_proof__mutmut_30, 
    'x_verify_proof__mutmut_31': x_verify_proof__mutmut_31, 
    'x_verify_proof__mutmut_32': x_verify_proof__mutmut_32, 
    'x_verify_proof__mutmut_33': x_verify_proof__mutmut_33, 
    'x_verify_proof__mutmut_34': x_verify_proof__mutmut_34, 
    'x_verify_proof__mutmut_35': x_verify_proof__mutmut_35, 
    'x_verify_proof__mutmut_36': x_verify_proof__mutmut_36, 
    'x_verify_proof__mutmut_37': x_verify_proof__mutmut_37, 
    'x_verify_proof__mutmut_38': x_verify_proof__mutmut_38, 
    'x_verify_proof__mutmut_39': x_verify_proof__mutmut_39
}

def verify_proof(*args, **kwargs):
    result = _mutmut_trampoline(x_verify_proof__mutmut_orig, x_verify_proof__mutmut_mutants, args, kwargs)
    return result 

verify_proof.__signature__ = _mutmut_signature(x_verify_proof__mutmut_orig)
x_verify_proof__mutmut_orig.__name__ = 'x_verify_proof'


def x__verify_risc0_receipt__mutmut_orig(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_1(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() and not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_2(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() and not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_3(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_4(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_5(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_6(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return True
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_7(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = None
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_8(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(None)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_9(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = None
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_10(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" * "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_11(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" * "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_12(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" * "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_13(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent * "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_14(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "XXrisc0XX" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_15(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "RISC0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_16(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "XXtargetXX" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_17(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "TARGET" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_18(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "XXreleaseXX" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_19(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "RELEASE" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_20(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "XXidi_risc0_hostXX"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_21(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "IDI_RISC0_HOST"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_22(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_23(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                None,
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_24(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                None
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_25(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_26(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_27(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "XXRisc0 verifier binary not found at %s. XX"
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_28(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_29(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "RISC0 VERIFIER BINARY NOT FOUND AT %S. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_30(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "XXBuild it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_hostXX",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_31(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_32(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "BUILD IT WITH: CD IDI/ZK/RISC0 && CARGO BUILD --RELEASE -P IDI_RISC0_HOST",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_33(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return True
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_34(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = None
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_35(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            None,
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_36(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=None,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_37(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=None,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_38(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=None,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_39(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_40(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_41(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_42(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_43(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(None),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_44(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "XXverifyXX",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_45(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "VERIFY",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_46(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "XX--proofXX",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_47(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--PROOF",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_48(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(None),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_49(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "XX--manifestXX",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_50(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--MANIFEST",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_51(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(None),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_52(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "XX--streamsXX",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_53(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--STREAMS",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_54(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(None),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_55(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=False,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_56(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=31,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_57(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=True,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_58(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode == 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_59(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 1:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_60(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = None
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_61(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode(None, errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_62(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors=None).strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_63(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode(errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_64(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", ).strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_65(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("XXutf-8XX", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_66(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("UTF-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_67(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="XXreplaceXX").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_68(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="REPLACE").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_69(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error(None, result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_70(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", None, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_71(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, None)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_72(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error(result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_73(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_74(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, )
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_75(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("XXRisc0 verifier failed (code %s): %sXX", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_76(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_77(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("RISC0 VERIFIER FAILED (CODE %S): %S", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_78(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return True
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_79(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return False
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_80(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error(None, e)
        return False


def x__verify_risc0_receipt__mutmut_81(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", None)
        return False


def x__verify_risc0_receipt__mutmut_82(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error(e)
        return False


def x__verify_risc0_receipt__mutmut_83(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", )
        return False


def x__verify_risc0_receipt__mutmut_84(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("XXError invoking Risc0 verifier: %sXX", e)
        return False


def x__verify_risc0_receipt__mutmut_85(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("error invoking risc0 verifier: %s", e)
        return False


def x__verify_risc0_receipt__mutmut_86(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("ERROR INVOKING RISC0 VERIFIER: %S", e)
        return False


def x__verify_risc0_receipt__mutmut_87(proof_path: Path, manifest_path: Path, stream_dir: Path) -> bool:
    """Verify a Risc0 receipt by calling the verifier binary with inputs bound.
    
    Security: This function requires a prebuilt verifier binary. It will NOT
    fall back to 'cargo run' to avoid triggering builds during verification,
    which could be slow, unpredictable, or a security risk if source is modified.
    
    To build the verifier, run:
        cd idi/zk/risc0 && cargo build --release -p idi_risc0_host
    """
    import subprocess
    import logging
    from pathlib import Path
    
    if not proof_path.exists() or not manifest_path.exists() or not stream_dir.exists():
        return False
    
    try:
        current_file = Path(__file__)
        risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
        
        if not risc0_host.exists():
            # Do NOT fall back to cargo run - require prebuilt binary
            logging.warning(
                "Risc0 verifier binary not found at %s. "
                "Build it with: cd idi/zk/risc0 && cargo build --release -p idi_risc0_host",
                risc0_host
            )
            return False
        
        result = subprocess.run(
            [
                str(risc0_host),
                "verify",
                "--proof",
                str(proof_path),
                "--manifest",
                str(manifest_path),
                "--streams",
                str(stream_dir),
            ],
            capture_output=True,
            timeout=30,
            check=False,
        )
        
        if result.returncode != 0:
            stderr = result.stderr.decode("utf-8", errors="replace").strip()
            logging.error("Risc0 verifier failed (code %s): %s", result.returncode, stderr)
            return False
        
        return True
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        logging.error("Error invoking Risc0 verifier: %s", e)
        return True

x__verify_risc0_receipt__mutmut_mutants : ClassVar[MutantDict] = {
'x__verify_risc0_receipt__mutmut_1': x__verify_risc0_receipt__mutmut_1, 
    'x__verify_risc0_receipt__mutmut_2': x__verify_risc0_receipt__mutmut_2, 
    'x__verify_risc0_receipt__mutmut_3': x__verify_risc0_receipt__mutmut_3, 
    'x__verify_risc0_receipt__mutmut_4': x__verify_risc0_receipt__mutmut_4, 
    'x__verify_risc0_receipt__mutmut_5': x__verify_risc0_receipt__mutmut_5, 
    'x__verify_risc0_receipt__mutmut_6': x__verify_risc0_receipt__mutmut_6, 
    'x__verify_risc0_receipt__mutmut_7': x__verify_risc0_receipt__mutmut_7, 
    'x__verify_risc0_receipt__mutmut_8': x__verify_risc0_receipt__mutmut_8, 
    'x__verify_risc0_receipt__mutmut_9': x__verify_risc0_receipt__mutmut_9, 
    'x__verify_risc0_receipt__mutmut_10': x__verify_risc0_receipt__mutmut_10, 
    'x__verify_risc0_receipt__mutmut_11': x__verify_risc0_receipt__mutmut_11, 
    'x__verify_risc0_receipt__mutmut_12': x__verify_risc0_receipt__mutmut_12, 
    'x__verify_risc0_receipt__mutmut_13': x__verify_risc0_receipt__mutmut_13, 
    'x__verify_risc0_receipt__mutmut_14': x__verify_risc0_receipt__mutmut_14, 
    'x__verify_risc0_receipt__mutmut_15': x__verify_risc0_receipt__mutmut_15, 
    'x__verify_risc0_receipt__mutmut_16': x__verify_risc0_receipt__mutmut_16, 
    'x__verify_risc0_receipt__mutmut_17': x__verify_risc0_receipt__mutmut_17, 
    'x__verify_risc0_receipt__mutmut_18': x__verify_risc0_receipt__mutmut_18, 
    'x__verify_risc0_receipt__mutmut_19': x__verify_risc0_receipt__mutmut_19, 
    'x__verify_risc0_receipt__mutmut_20': x__verify_risc0_receipt__mutmut_20, 
    'x__verify_risc0_receipt__mutmut_21': x__verify_risc0_receipt__mutmut_21, 
    'x__verify_risc0_receipt__mutmut_22': x__verify_risc0_receipt__mutmut_22, 
    'x__verify_risc0_receipt__mutmut_23': x__verify_risc0_receipt__mutmut_23, 
    'x__verify_risc0_receipt__mutmut_24': x__verify_risc0_receipt__mutmut_24, 
    'x__verify_risc0_receipt__mutmut_25': x__verify_risc0_receipt__mutmut_25, 
    'x__verify_risc0_receipt__mutmut_26': x__verify_risc0_receipt__mutmut_26, 
    'x__verify_risc0_receipt__mutmut_27': x__verify_risc0_receipt__mutmut_27, 
    'x__verify_risc0_receipt__mutmut_28': x__verify_risc0_receipt__mutmut_28, 
    'x__verify_risc0_receipt__mutmut_29': x__verify_risc0_receipt__mutmut_29, 
    'x__verify_risc0_receipt__mutmut_30': x__verify_risc0_receipt__mutmut_30, 
    'x__verify_risc0_receipt__mutmut_31': x__verify_risc0_receipt__mutmut_31, 
    'x__verify_risc0_receipt__mutmut_32': x__verify_risc0_receipt__mutmut_32, 
    'x__verify_risc0_receipt__mutmut_33': x__verify_risc0_receipt__mutmut_33, 
    'x__verify_risc0_receipt__mutmut_34': x__verify_risc0_receipt__mutmut_34, 
    'x__verify_risc0_receipt__mutmut_35': x__verify_risc0_receipt__mutmut_35, 
    'x__verify_risc0_receipt__mutmut_36': x__verify_risc0_receipt__mutmut_36, 
    'x__verify_risc0_receipt__mutmut_37': x__verify_risc0_receipt__mutmut_37, 
    'x__verify_risc0_receipt__mutmut_38': x__verify_risc0_receipt__mutmut_38, 
    'x__verify_risc0_receipt__mutmut_39': x__verify_risc0_receipt__mutmut_39, 
    'x__verify_risc0_receipt__mutmut_40': x__verify_risc0_receipt__mutmut_40, 
    'x__verify_risc0_receipt__mutmut_41': x__verify_risc0_receipt__mutmut_41, 
    'x__verify_risc0_receipt__mutmut_42': x__verify_risc0_receipt__mutmut_42, 
    'x__verify_risc0_receipt__mutmut_43': x__verify_risc0_receipt__mutmut_43, 
    'x__verify_risc0_receipt__mutmut_44': x__verify_risc0_receipt__mutmut_44, 
    'x__verify_risc0_receipt__mutmut_45': x__verify_risc0_receipt__mutmut_45, 
    'x__verify_risc0_receipt__mutmut_46': x__verify_risc0_receipt__mutmut_46, 
    'x__verify_risc0_receipt__mutmut_47': x__verify_risc0_receipt__mutmut_47, 
    'x__verify_risc0_receipt__mutmut_48': x__verify_risc0_receipt__mutmut_48, 
    'x__verify_risc0_receipt__mutmut_49': x__verify_risc0_receipt__mutmut_49, 
    'x__verify_risc0_receipt__mutmut_50': x__verify_risc0_receipt__mutmut_50, 
    'x__verify_risc0_receipt__mutmut_51': x__verify_risc0_receipt__mutmut_51, 
    'x__verify_risc0_receipt__mutmut_52': x__verify_risc0_receipt__mutmut_52, 
    'x__verify_risc0_receipt__mutmut_53': x__verify_risc0_receipt__mutmut_53, 
    'x__verify_risc0_receipt__mutmut_54': x__verify_risc0_receipt__mutmut_54, 
    'x__verify_risc0_receipt__mutmut_55': x__verify_risc0_receipt__mutmut_55, 
    'x__verify_risc0_receipt__mutmut_56': x__verify_risc0_receipt__mutmut_56, 
    'x__verify_risc0_receipt__mutmut_57': x__verify_risc0_receipt__mutmut_57, 
    'x__verify_risc0_receipt__mutmut_58': x__verify_risc0_receipt__mutmut_58, 
    'x__verify_risc0_receipt__mutmut_59': x__verify_risc0_receipt__mutmut_59, 
    'x__verify_risc0_receipt__mutmut_60': x__verify_risc0_receipt__mutmut_60, 
    'x__verify_risc0_receipt__mutmut_61': x__verify_risc0_receipt__mutmut_61, 
    'x__verify_risc0_receipt__mutmut_62': x__verify_risc0_receipt__mutmut_62, 
    'x__verify_risc0_receipt__mutmut_63': x__verify_risc0_receipt__mutmut_63, 
    'x__verify_risc0_receipt__mutmut_64': x__verify_risc0_receipt__mutmut_64, 
    'x__verify_risc0_receipt__mutmut_65': x__verify_risc0_receipt__mutmut_65, 
    'x__verify_risc0_receipt__mutmut_66': x__verify_risc0_receipt__mutmut_66, 
    'x__verify_risc0_receipt__mutmut_67': x__verify_risc0_receipt__mutmut_67, 
    'x__verify_risc0_receipt__mutmut_68': x__verify_risc0_receipt__mutmut_68, 
    'x__verify_risc0_receipt__mutmut_69': x__verify_risc0_receipt__mutmut_69, 
    'x__verify_risc0_receipt__mutmut_70': x__verify_risc0_receipt__mutmut_70, 
    'x__verify_risc0_receipt__mutmut_71': x__verify_risc0_receipt__mutmut_71, 
    'x__verify_risc0_receipt__mutmut_72': x__verify_risc0_receipt__mutmut_72, 
    'x__verify_risc0_receipt__mutmut_73': x__verify_risc0_receipt__mutmut_73, 
    'x__verify_risc0_receipt__mutmut_74': x__verify_risc0_receipt__mutmut_74, 
    'x__verify_risc0_receipt__mutmut_75': x__verify_risc0_receipt__mutmut_75, 
    'x__verify_risc0_receipt__mutmut_76': x__verify_risc0_receipt__mutmut_76, 
    'x__verify_risc0_receipt__mutmut_77': x__verify_risc0_receipt__mutmut_77, 
    'x__verify_risc0_receipt__mutmut_78': x__verify_risc0_receipt__mutmut_78, 
    'x__verify_risc0_receipt__mutmut_79': x__verify_risc0_receipt__mutmut_79, 
    'x__verify_risc0_receipt__mutmut_80': x__verify_risc0_receipt__mutmut_80, 
    'x__verify_risc0_receipt__mutmut_81': x__verify_risc0_receipt__mutmut_81, 
    'x__verify_risc0_receipt__mutmut_82': x__verify_risc0_receipt__mutmut_82, 
    'x__verify_risc0_receipt__mutmut_83': x__verify_risc0_receipt__mutmut_83, 
    'x__verify_risc0_receipt__mutmut_84': x__verify_risc0_receipt__mutmut_84, 
    'x__verify_risc0_receipt__mutmut_85': x__verify_risc0_receipt__mutmut_85, 
    'x__verify_risc0_receipt__mutmut_86': x__verify_risc0_receipt__mutmut_86, 
    'x__verify_risc0_receipt__mutmut_87': x__verify_risc0_receipt__mutmut_87
}

def _verify_risc0_receipt(*args, **kwargs):
    result = _mutmut_trampoline(x__verify_risc0_receipt__mutmut_orig, x__verify_risc0_receipt__mutmut_mutants, args, kwargs)
    return result 

_verify_risc0_receipt.__signature__ = _mutmut_signature(x__verify_risc0_receipt__mutmut_orig)
x__verify_risc0_receipt__mutmut_orig.__name__ = 'x__verify_risc0_receipt'


def x_verify_zk_receipt__mutmut_orig(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_1(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 31,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_2(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_3(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            None,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_4(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            None,
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_5(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_6(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_7(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_8(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            None,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_9(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            None,
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_10(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_11(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_12(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_13(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            None,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_14(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            None,
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_15(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_16(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_17(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = None
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_18(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(None)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_19(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = None
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_20(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" * "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_21(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" * "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_22(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" * "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_23(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent * "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_24(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "XXrisc0XX" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_25(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "RISC0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_26(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "XXtargetXX" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_27(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "TARGET" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_28(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "XXreleaseXX" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_29(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "RELEASE" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_30(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "XXidi_risc0_hostXX"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_31(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "IDI_RISC0_HOST"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_32(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_33(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            None,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_34(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            None,
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_35(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=None,
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_36(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_37(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_38(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_39(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(None),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_40(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = None
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_41(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(None),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_42(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "XXverifyXX",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_43(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "VERIFY",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_44(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "XX--proofXX", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_45(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--PROOF", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_46(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(None),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_47(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "XX--manifestXX", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_48(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--MANIFEST", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_49(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(None),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_50(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "XX--streamsXX", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_51(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--STREAMS", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_52(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(None),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_53(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(None)
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_54(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["XX--method-idXX", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_55(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--METHOD-ID", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_56(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(None)
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_57(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["XX--journal-digestXX", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_58(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--JOURNAL-DIGEST", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_59(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = None
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_60(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            None,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_61(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=None,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_62(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=None,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_63(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=None,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_64(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_65(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_66(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_67(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_68(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=False,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_69(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=True,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_70(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode != 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_71(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 1:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_72(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                None,
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_73(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=None,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_74(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_75(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_76(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "XXZK proof verified successfullyXX",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_77(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "zk proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_78(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK PROOF VERIFIED SUCCESSFULLY",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_79(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = None
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_80(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode(None, errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_81(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors=None).strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_82(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode(errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_83(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", ).strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_84(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("XXutf-8XX", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_85(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("UTF-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_86(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="XXreplaceXX").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_87(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="REPLACE").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_88(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "XXMethod ID mismatchXX" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_89(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "method id mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_90(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "METHOD ID MISMATCH" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_91(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" not in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_92(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                None,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_93(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                None,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_94(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=None,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_95(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_96(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_97(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_98(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "XXJournal digest mismatchXX" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_99(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_100(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "JOURNAL DIGEST MISMATCH" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_101(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" not in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_102(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                None,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_103(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                None,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_104(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=None,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_105(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_106(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_107(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_108(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr or "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_109(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "XXguest digestXX" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_110(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "GUEST DIGEST" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_111(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" not in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_112(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "XXdoes not matchXX" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_113(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "DOES NOT MATCH" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_114(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" not in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_115(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                None,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_116(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                None,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_117(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_118(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_119(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                None,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_120(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                None,
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_121(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=None,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_122(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_123(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_124(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_125(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            None,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_126(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            None,
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_127(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_128(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_129(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            None,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_130(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            None,
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_131(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_132(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_133(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            None,
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_134(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            None,
        )


def x_verify_zk_receipt__mutmut_135(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            f"OS error during verification: {e}",
        )


def x_verify_zk_receipt__mutmut_136(
    proof_path: Path,
    manifest_path: Path,
    stream_dir: Path,
    expected_method_id: str | None = None,
    expected_journal_digest: str | None = None,
    timeout_s: int = 30,
) -> "VerificationReport":
    """Verify a ZK receipt with method ID and journal digest enforcement.
    
    This is the secure verification function that enforces cryptographic
    binding of the proof to specific program logic (method ID) and data
    (journal digest).
    
    Args:
        proof_path: Path to proof binary file
        manifest_path: Path to manifest JSON file
        stream_dir: Directory containing stream files
        expected_method_id: Required method ID (hex) for Risc0 proofs
        expected_journal_digest: Optional expected journal digest (hex)
        timeout_s: Verification timeout in seconds
        
    Returns:
        VerificationReport with success/failure and error details
        
    Security:
        - Requires prebuilt verifier binary (no cargo run fallback)
        - Enforces method ID if provided (prevents program substitution)
        - Verifies journal digest matches commitment
    """
    import subprocess
    import logging
    from pathlib import Path
    from idi.zk.verification import VerificationReport, VerificationErrorCode
    
    # Check file existence
    if not proof_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.RECEIPT_MISSING,
            f"Proof file not found: {proof_path}",
        )
    if not manifest_path.exists():
        return VerificationReport.fail(
            VerificationErrorCode.MANIFEST_MISSING,
            f"Manifest file not found: {manifest_path}",
        )
    if not stream_dir.exists():
        return VerificationReport.fail(
            VerificationErrorCode.STREAMS_MISSING,
            f"Streams directory not found: {stream_dir}",
        )
    
    # Locate verifier binary
    current_file = Path(__file__)
    risc0_host = current_file.parent / "risc0" / "target" / "release" / "idi_risc0_host"
    
    if not risc0_host.exists():
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Risc0 verifier not found. Build with: cd idi/zk/risc0 && cargo build --release",
            binary_path=str(risc0_host),
        )
    
    # Build command
    cmd = [
        str(risc0_host),
        "verify",
        "--proof", str(proof_path),
        "--manifest", str(manifest_path),
        "--streams", str(stream_dir),
    ]
    
    if expected_method_id:
        cmd.extend(["--method-id", expected_method_id])
    
    if expected_journal_digest:
        cmd.extend(["--journal-digest", expected_journal_digest])
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            timeout=timeout_s,
            check=False,
        )
        
        if result.returncode == 0:
            return VerificationReport.ok(
                "ZK proof verified successfully",
                method_id=expected_method_id,
            )
        
        # Parse error from stderr
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        
        if "Method ID mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.METHOD_ID_MISMATCH,
                stderr,
                expected=expected_method_id,
            )
        elif "Journal digest mismatch" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.JOURNAL_DIGEST_MISMATCH,
                stderr,
                expected=expected_journal_digest,
            )
        elif "guest digest" in stderr and "does not match" in stderr:
            return VerificationReport.fail(
                VerificationErrorCode.COMMITMENT_MISMATCH,
                stderr,
            )
        else:
            return VerificationReport.fail(
                VerificationErrorCode.ZK_RECEIPT_INVALID,
                f"Verification failed: {stderr}",
                returncode=result.returncode,
            )
            
    except subprocess.TimeoutExpired:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_TIMEOUT,
            f"Verification timed out after {timeout_s}s",
        )
    except FileNotFoundError:
        return VerificationReport.fail(
            VerificationErrorCode.VERIFIER_UNAVAILABLE,
            f"Verifier binary not found: {risc0_host}",
        )
    except OSError as e:
        return VerificationReport.fail(
            VerificationErrorCode.INTERNAL_ERROR,
            )

x_verify_zk_receipt__mutmut_mutants : ClassVar[MutantDict] = {
'x_verify_zk_receipt__mutmut_1': x_verify_zk_receipt__mutmut_1, 
    'x_verify_zk_receipt__mutmut_2': x_verify_zk_receipt__mutmut_2, 
    'x_verify_zk_receipt__mutmut_3': x_verify_zk_receipt__mutmut_3, 
    'x_verify_zk_receipt__mutmut_4': x_verify_zk_receipt__mutmut_4, 
    'x_verify_zk_receipt__mutmut_5': x_verify_zk_receipt__mutmut_5, 
    'x_verify_zk_receipt__mutmut_6': x_verify_zk_receipt__mutmut_6, 
    'x_verify_zk_receipt__mutmut_7': x_verify_zk_receipt__mutmut_7, 
    'x_verify_zk_receipt__mutmut_8': x_verify_zk_receipt__mutmut_8, 
    'x_verify_zk_receipt__mutmut_9': x_verify_zk_receipt__mutmut_9, 
    'x_verify_zk_receipt__mutmut_10': x_verify_zk_receipt__mutmut_10, 
    'x_verify_zk_receipt__mutmut_11': x_verify_zk_receipt__mutmut_11, 
    'x_verify_zk_receipt__mutmut_12': x_verify_zk_receipt__mutmut_12, 
    'x_verify_zk_receipt__mutmut_13': x_verify_zk_receipt__mutmut_13, 
    'x_verify_zk_receipt__mutmut_14': x_verify_zk_receipt__mutmut_14, 
    'x_verify_zk_receipt__mutmut_15': x_verify_zk_receipt__mutmut_15, 
    'x_verify_zk_receipt__mutmut_16': x_verify_zk_receipt__mutmut_16, 
    'x_verify_zk_receipt__mutmut_17': x_verify_zk_receipt__mutmut_17, 
    'x_verify_zk_receipt__mutmut_18': x_verify_zk_receipt__mutmut_18, 
    'x_verify_zk_receipt__mutmut_19': x_verify_zk_receipt__mutmut_19, 
    'x_verify_zk_receipt__mutmut_20': x_verify_zk_receipt__mutmut_20, 
    'x_verify_zk_receipt__mutmut_21': x_verify_zk_receipt__mutmut_21, 
    'x_verify_zk_receipt__mutmut_22': x_verify_zk_receipt__mutmut_22, 
    'x_verify_zk_receipt__mutmut_23': x_verify_zk_receipt__mutmut_23, 
    'x_verify_zk_receipt__mutmut_24': x_verify_zk_receipt__mutmut_24, 
    'x_verify_zk_receipt__mutmut_25': x_verify_zk_receipt__mutmut_25, 
    'x_verify_zk_receipt__mutmut_26': x_verify_zk_receipt__mutmut_26, 
    'x_verify_zk_receipt__mutmut_27': x_verify_zk_receipt__mutmut_27, 
    'x_verify_zk_receipt__mutmut_28': x_verify_zk_receipt__mutmut_28, 
    'x_verify_zk_receipt__mutmut_29': x_verify_zk_receipt__mutmut_29, 
    'x_verify_zk_receipt__mutmut_30': x_verify_zk_receipt__mutmut_30, 
    'x_verify_zk_receipt__mutmut_31': x_verify_zk_receipt__mutmut_31, 
    'x_verify_zk_receipt__mutmut_32': x_verify_zk_receipt__mutmut_32, 
    'x_verify_zk_receipt__mutmut_33': x_verify_zk_receipt__mutmut_33, 
    'x_verify_zk_receipt__mutmut_34': x_verify_zk_receipt__mutmut_34, 
    'x_verify_zk_receipt__mutmut_35': x_verify_zk_receipt__mutmut_35, 
    'x_verify_zk_receipt__mutmut_36': x_verify_zk_receipt__mutmut_36, 
    'x_verify_zk_receipt__mutmut_37': x_verify_zk_receipt__mutmut_37, 
    'x_verify_zk_receipt__mutmut_38': x_verify_zk_receipt__mutmut_38, 
    'x_verify_zk_receipt__mutmut_39': x_verify_zk_receipt__mutmut_39, 
    'x_verify_zk_receipt__mutmut_40': x_verify_zk_receipt__mutmut_40, 
    'x_verify_zk_receipt__mutmut_41': x_verify_zk_receipt__mutmut_41, 
    'x_verify_zk_receipt__mutmut_42': x_verify_zk_receipt__mutmut_42, 
    'x_verify_zk_receipt__mutmut_43': x_verify_zk_receipt__mutmut_43, 
    'x_verify_zk_receipt__mutmut_44': x_verify_zk_receipt__mutmut_44, 
    'x_verify_zk_receipt__mutmut_45': x_verify_zk_receipt__mutmut_45, 
    'x_verify_zk_receipt__mutmut_46': x_verify_zk_receipt__mutmut_46, 
    'x_verify_zk_receipt__mutmut_47': x_verify_zk_receipt__mutmut_47, 
    'x_verify_zk_receipt__mutmut_48': x_verify_zk_receipt__mutmut_48, 
    'x_verify_zk_receipt__mutmut_49': x_verify_zk_receipt__mutmut_49, 
    'x_verify_zk_receipt__mutmut_50': x_verify_zk_receipt__mutmut_50, 
    'x_verify_zk_receipt__mutmut_51': x_verify_zk_receipt__mutmut_51, 
    'x_verify_zk_receipt__mutmut_52': x_verify_zk_receipt__mutmut_52, 
    'x_verify_zk_receipt__mutmut_53': x_verify_zk_receipt__mutmut_53, 
    'x_verify_zk_receipt__mutmut_54': x_verify_zk_receipt__mutmut_54, 
    'x_verify_zk_receipt__mutmut_55': x_verify_zk_receipt__mutmut_55, 
    'x_verify_zk_receipt__mutmut_56': x_verify_zk_receipt__mutmut_56, 
    'x_verify_zk_receipt__mutmut_57': x_verify_zk_receipt__mutmut_57, 
    'x_verify_zk_receipt__mutmut_58': x_verify_zk_receipt__mutmut_58, 
    'x_verify_zk_receipt__mutmut_59': x_verify_zk_receipt__mutmut_59, 
    'x_verify_zk_receipt__mutmut_60': x_verify_zk_receipt__mutmut_60, 
    'x_verify_zk_receipt__mutmut_61': x_verify_zk_receipt__mutmut_61, 
    'x_verify_zk_receipt__mutmut_62': x_verify_zk_receipt__mutmut_62, 
    'x_verify_zk_receipt__mutmut_63': x_verify_zk_receipt__mutmut_63, 
    'x_verify_zk_receipt__mutmut_64': x_verify_zk_receipt__mutmut_64, 
    'x_verify_zk_receipt__mutmut_65': x_verify_zk_receipt__mutmut_65, 
    'x_verify_zk_receipt__mutmut_66': x_verify_zk_receipt__mutmut_66, 
    'x_verify_zk_receipt__mutmut_67': x_verify_zk_receipt__mutmut_67, 
    'x_verify_zk_receipt__mutmut_68': x_verify_zk_receipt__mutmut_68, 
    'x_verify_zk_receipt__mutmut_69': x_verify_zk_receipt__mutmut_69, 
    'x_verify_zk_receipt__mutmut_70': x_verify_zk_receipt__mutmut_70, 
    'x_verify_zk_receipt__mutmut_71': x_verify_zk_receipt__mutmut_71, 
    'x_verify_zk_receipt__mutmut_72': x_verify_zk_receipt__mutmut_72, 
    'x_verify_zk_receipt__mutmut_73': x_verify_zk_receipt__mutmut_73, 
    'x_verify_zk_receipt__mutmut_74': x_verify_zk_receipt__mutmut_74, 
    'x_verify_zk_receipt__mutmut_75': x_verify_zk_receipt__mutmut_75, 
    'x_verify_zk_receipt__mutmut_76': x_verify_zk_receipt__mutmut_76, 
    'x_verify_zk_receipt__mutmut_77': x_verify_zk_receipt__mutmut_77, 
    'x_verify_zk_receipt__mutmut_78': x_verify_zk_receipt__mutmut_78, 
    'x_verify_zk_receipt__mutmut_79': x_verify_zk_receipt__mutmut_79, 
    'x_verify_zk_receipt__mutmut_80': x_verify_zk_receipt__mutmut_80, 
    'x_verify_zk_receipt__mutmut_81': x_verify_zk_receipt__mutmut_81, 
    'x_verify_zk_receipt__mutmut_82': x_verify_zk_receipt__mutmut_82, 
    'x_verify_zk_receipt__mutmut_83': x_verify_zk_receipt__mutmut_83, 
    'x_verify_zk_receipt__mutmut_84': x_verify_zk_receipt__mutmut_84, 
    'x_verify_zk_receipt__mutmut_85': x_verify_zk_receipt__mutmut_85, 
    'x_verify_zk_receipt__mutmut_86': x_verify_zk_receipt__mutmut_86, 
    'x_verify_zk_receipt__mutmut_87': x_verify_zk_receipt__mutmut_87, 
    'x_verify_zk_receipt__mutmut_88': x_verify_zk_receipt__mutmut_88, 
    'x_verify_zk_receipt__mutmut_89': x_verify_zk_receipt__mutmut_89, 
    'x_verify_zk_receipt__mutmut_90': x_verify_zk_receipt__mutmut_90, 
    'x_verify_zk_receipt__mutmut_91': x_verify_zk_receipt__mutmut_91, 
    'x_verify_zk_receipt__mutmut_92': x_verify_zk_receipt__mutmut_92, 
    'x_verify_zk_receipt__mutmut_93': x_verify_zk_receipt__mutmut_93, 
    'x_verify_zk_receipt__mutmut_94': x_verify_zk_receipt__mutmut_94, 
    'x_verify_zk_receipt__mutmut_95': x_verify_zk_receipt__mutmut_95, 
    'x_verify_zk_receipt__mutmut_96': x_verify_zk_receipt__mutmut_96, 
    'x_verify_zk_receipt__mutmut_97': x_verify_zk_receipt__mutmut_97, 
    'x_verify_zk_receipt__mutmut_98': x_verify_zk_receipt__mutmut_98, 
    'x_verify_zk_receipt__mutmut_99': x_verify_zk_receipt__mutmut_99, 
    'x_verify_zk_receipt__mutmut_100': x_verify_zk_receipt__mutmut_100, 
    'x_verify_zk_receipt__mutmut_101': x_verify_zk_receipt__mutmut_101, 
    'x_verify_zk_receipt__mutmut_102': x_verify_zk_receipt__mutmut_102, 
    'x_verify_zk_receipt__mutmut_103': x_verify_zk_receipt__mutmut_103, 
    'x_verify_zk_receipt__mutmut_104': x_verify_zk_receipt__mutmut_104, 
    'x_verify_zk_receipt__mutmut_105': x_verify_zk_receipt__mutmut_105, 
    'x_verify_zk_receipt__mutmut_106': x_verify_zk_receipt__mutmut_106, 
    'x_verify_zk_receipt__mutmut_107': x_verify_zk_receipt__mutmut_107, 
    'x_verify_zk_receipt__mutmut_108': x_verify_zk_receipt__mutmut_108, 
    'x_verify_zk_receipt__mutmut_109': x_verify_zk_receipt__mutmut_109, 
    'x_verify_zk_receipt__mutmut_110': x_verify_zk_receipt__mutmut_110, 
    'x_verify_zk_receipt__mutmut_111': x_verify_zk_receipt__mutmut_111, 
    'x_verify_zk_receipt__mutmut_112': x_verify_zk_receipt__mutmut_112, 
    'x_verify_zk_receipt__mutmut_113': x_verify_zk_receipt__mutmut_113, 
    'x_verify_zk_receipt__mutmut_114': x_verify_zk_receipt__mutmut_114, 
    'x_verify_zk_receipt__mutmut_115': x_verify_zk_receipt__mutmut_115, 
    'x_verify_zk_receipt__mutmut_116': x_verify_zk_receipt__mutmut_116, 
    'x_verify_zk_receipt__mutmut_117': x_verify_zk_receipt__mutmut_117, 
    'x_verify_zk_receipt__mutmut_118': x_verify_zk_receipt__mutmut_118, 
    'x_verify_zk_receipt__mutmut_119': x_verify_zk_receipt__mutmut_119, 
    'x_verify_zk_receipt__mutmut_120': x_verify_zk_receipt__mutmut_120, 
    'x_verify_zk_receipt__mutmut_121': x_verify_zk_receipt__mutmut_121, 
    'x_verify_zk_receipt__mutmut_122': x_verify_zk_receipt__mutmut_122, 
    'x_verify_zk_receipt__mutmut_123': x_verify_zk_receipt__mutmut_123, 
    'x_verify_zk_receipt__mutmut_124': x_verify_zk_receipt__mutmut_124, 
    'x_verify_zk_receipt__mutmut_125': x_verify_zk_receipt__mutmut_125, 
    'x_verify_zk_receipt__mutmut_126': x_verify_zk_receipt__mutmut_126, 
    'x_verify_zk_receipt__mutmut_127': x_verify_zk_receipt__mutmut_127, 
    'x_verify_zk_receipt__mutmut_128': x_verify_zk_receipt__mutmut_128, 
    'x_verify_zk_receipt__mutmut_129': x_verify_zk_receipt__mutmut_129, 
    'x_verify_zk_receipt__mutmut_130': x_verify_zk_receipt__mutmut_130, 
    'x_verify_zk_receipt__mutmut_131': x_verify_zk_receipt__mutmut_131, 
    'x_verify_zk_receipt__mutmut_132': x_verify_zk_receipt__mutmut_132, 
    'x_verify_zk_receipt__mutmut_133': x_verify_zk_receipt__mutmut_133, 
    'x_verify_zk_receipt__mutmut_134': x_verify_zk_receipt__mutmut_134, 
    'x_verify_zk_receipt__mutmut_135': x_verify_zk_receipt__mutmut_135, 
    'x_verify_zk_receipt__mutmut_136': x_verify_zk_receipt__mutmut_136
}

def verify_zk_receipt(*args, **kwargs):
    result = _mutmut_trampoline(x_verify_zk_receipt__mutmut_orig, x_verify_zk_receipt__mutmut_mutants, args, kwargs)
    return result 

verify_zk_receipt.__signature__ = _mutmut_signature(x_verify_zk_receipt__mutmut_orig)
x_verify_zk_receipt__mutmut_orig.__name__ = 'x_verify_zk_receipt'
